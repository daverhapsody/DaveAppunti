\documentclass[12pt, a4paper, openany, twoside]{book}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath} 
\usepackage{xcolor}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\graphicspath{{./img/}}
\usepackage{tikz}
\hypersetup{
colorlinks=true,
linkcolor=blue,
filecolor=magenta,      
urlcolor=cyan,
}
%usepackage[latin1]{inputenc}
\begin{document}
\fontfamily{cmss}\selectfont
\pagestyle{plain}
\author{DaveRhapsody}
\title {Sistemi Distribuiti}
\date {11 Marzo 2020}
\maketitle
\tableofcontents
\chapter{Introduzione}
Un sistema distribuito è un insieme di componenti hardware e software che 
comunicano tramite scambi di messaggi in rete.
Il concetto di componente è fondamentale, può essere per l'appunto sia hardware
che software.
\paragraph{Nel dettaglio:} E' un sistema di componenti \textbf{autonome},
nel senso che le componenti sono indipendenti tra loro MA concorrono tutte
allo stesso scopo. Per apparire come unico componente occorre generare una
sorta di collaborazione \textbf{SENZA} memoria condivisa.
\paragraph{Autonomia:} Ognuno svolge il proprio compito in modo indipendente
(sia in termini di tempo che dati) da ogni altro. Pertanto occorre che le
componenti siano \textbf{SINCRONIZZATE} (Reti e Sistemi insegna ->).
Questo insieme di nodi appaiono all'utente finale come un unico sistema
\textbf{coerente} senza che lui sappia dove vengono processati (e nemmeno
come) i dati. Il sistema è un blocco unico agli occhi dell'utente MA obv no.
\paragraph{Concetto di trasparenza:} Il livello di trasparenza lo si decide 
in fase di progettazione del sistema, fondamentalmente è il livello tale per 
cui l'utente sappia come vengono processati i dati, e cosa e come viene
eseguito dal sistema. (Un sistema trasparente, è un sistema che ti fa
vedere vita, morte, miracoli, luci, coriandoli, sassi e Babbo Natale).
\section{Caratteristiche fondamentali}
\begin{itemize}
	\item Non c'è memoria condivisa
	\item L'esecuzione è concorrente (allo stesso istante)
	\item Non ci sono stati del processo o della memoria, ogni nodo è a sè un
	processo!
	\item NON C'E' UN CLOCK GLOBALE, niente scheduling. controllo (globale),
	si fa tutto per scambio di messaggi
	\item Non esiste un fallimento globale ma un fallimento della singola
	componente. 
	\paragraph{Sistemi Realtime:} Noi non utilizziamo questo genere di 
	dispositivi, studiamo e prendiamo in esame dispositivi best-effort
	\item Architetture software
\end{itemize}
\section{Architetture software}
E' la struttura del sistema, di come sono organizzate le componenti, quali
sono i protocolli, le interfacce, etc.
\begin{itemize}
	\item Architetture a Livelli (tier)
	\item Architetture a oggetti
	\item Architetture centrate sui dati
	\item Architetture event-based (ajax)
\end{itemize}
\subsection{Stratificazione}
L'idea è formare degli strati di complessità, fondamentalmente nulla vieta di 
fare tutto a livello application, lì si impreca per davvero, ma soprattutto
non ci sarebbe una specializzazione. Il motto è "Fai una cosa, ma falla bene".
\section{Tipi di sistemi operativi}
In base al tipo ho un livello diverso di trasparenza
\begin{itemize}
	\item DOS: Distributed OS
	\item NOS: Network OS: L'OS ti dà delle librerie e supporti per supportare
	delle applicazioni MA non nasconde le comunicazioni tra le varie applicazioni.
	\item Middleware: Hai un insieme di sistemi di rete che forniscono primitive
	per sostenere comunicazione tra sistemi E costruirci delle logiche che 
	consentano di vedere questo come unico sistema (Sì, il middleware è 
	a sua volta un'applicazione distribuita)
	\section{Servizi del middleware}
	\begin{itemize}
		\item Naming
		\item Accesso trasparente
		\item Persisenza: avviene una memorizzazione di dati persistente
		\item Transazioni distribuite: Va garantita la consistenza dei dati
		\item Sicurezza dei dati: integrità computazionali
	\end{itemize}
	\paragraph{Riporto il riassunto presente nelle slides}  
	\begin{center}
	\includegraphics[width=0.75\textwidth]{1.png}
	\end{center}
\end{itemize}
\chapter{Modello Client-Server}
E' un'interazione basata su richiesta-risposta tra una componente e 
l'altra.
\paragraph{Funzionamento:}
\begin{enumerate}
	\item Client invia la request
	\item Server la riceve, client aspetta
	\item Server elabora
	\item Server risponde alla richiesta
\end{enumerate}
Quando client aspetta, quest'ultimo è in standby, in attesa, fermo, inchiodato.
Il server si attiva ad ogni richiesta che arriva. Richiesta e risposta hanno
un tempo ovviamente proprio, che deriva dalla rete di riferimento, chiaramente
se si fa tutto sulla stessa macchina si parla di microsecondi.
\paragraph{Osservazione:} Un dispositivo è sia client che server, può essere
sia uno che l'altro.
\paragraph{Tipi di accesso:}
\begin{itemize}
	\item Accesso a server multipli (nel senso che sono duplicati i server)
	\item Accesso via proxy
\end{itemize}
\section{Problemi dei Sistemi Distribuiti}
\begin{itemize}
	\item Identificazione della controparte: Identifico la risorsa, tipo con
	address etc.
	\item Accesso alla controparte: Dove accedo? Chi è il mio access point
	\item Comunicazione 1: Definisco il formato dei messaggi scambiati
	\item Comunicazione 2: Capisco il contenuto del messaggio in seguito 
	all'estrazione
	\paragraph{Esempio:} I tipi per i dati, che specificano un insieme 
	di valori ed operazioni fattibili su un determinato dato.
\end{itemize}
\section{Trasparenza}
Significa nascondere all'utente \textbf{come} viene ottenuto un determinato
risultato. E' per intenderci ciò che salva coloro che programmano tutto nel 
main.
Come si fa?
\begin{itemize}
	\item \textbf{Naming}: non mi connetto per indirizzo IP ma per indirizzo web, link.
	\item \textbf{Accesso trasparente}: Come accedo in maniera trasparente? Anche qui
	nomi simbolici, qualcosa che non mi faccia capire la locazione della 
	controparte
	\item \textbf{Location Trasparency}: Hai una stampante a casa e devi stampare una foto
	di gattini? Ti serve sapere dove si trova, non puoi cercare a caso su google,
	quindi devi sapere fisicamente dove hai la stampante. Invece se ti serve
	una calcolatrice online tipo wolfram alpha, digiti l'equazione, la risolve,
	ma tu non sai una bega di dove è stata risolta.
	\item \textbf{Relocation o trasparenza mobile}: Posso spostare le risorse mentre le
	uso (Cellulari, dispositivi wifi, ci siamo capiti).
	\item \textbf{Migrazione}: Posso spostare un sito web da un pc del 91 ad un pc del 
	2020, il servizio quello è, cambierà la velocità (tempi di elaborazione
	+ request + response)
	\item \textbf{Replicazione}: Hai una serie di server identici, tu ti connetti ad uno
	o l'altro, cambia niente
	\item \textbf{Concorrenza}: In più utenti accediamo allo stesso servizio (spotify)
	\item \textbf{Trasparenza del fallimento}: Ciò che resta dopo un fallimento di una
	componente deve colmare i danni di una componente morta.
	\item \textbf{Persistenza}: Non mi accorgo di quando un sistema è riavviato o no
\end{itemize}
In alcuni casi è impossibile nascondere un fail o lo stato di una applicazione,
se ti crasha Word, vedi che ti è crashato Word, quindi in qualche modo 
va comunicato all'utente "Ueh, fa schifo Uord, usa OpeNoFFiSsszsxxs". Ma
tra l'altro non sempre è utile nascondere, prendete l'esempio di prima della
stampante. 
\section{Separazione tra interfaccia e realizzazione}
Costruisco un'astrazione logica che nasconde i dettagli implementativi
di ciò che sta diestro. Ogni componente pubblica il What cioè COSA fa, ma non
ti spara fuori anche l'HOW, cioè COME lo fa, è il concetto di information
hiding di Java.
\paragraph{Esempio:}
Gestione delle stringhe nei vari linguaggi. Una stringa è una concatenazione
di caratteri, la gestione di append, copy, concat etc. sono how, il 
risultato finale è il what
\section{Politiche versus mechanism}
Un Sistema distribuito è composto da.. Va beh avete capito. Progressivamente
si va verso un unico enorme (utopico) sistema complesso organizzato con delle
policy stabilite. 
Le politiche banalmente sono una serie di regole ad esempio prendete il context
switch di Unix. 
\begin{itemize}
	\item Il CS è un meccanismo
	\item Il Round Robin invece è la policy di come è gestito un comportamento	
\end{itemize}
\section{Concetto di protocollo}
Un protocollo è un insieme di regole che definiscono un formato, l'ordine,
payload, operazioni da compiere alla ricezione od all'invio di un 
messaggio.
\chapter{Le Socket}
\paragraph{Cos'è?} Una socket è un'interfaccia tra il sistema operativo ed un 
processo su di esso eseguito, quindi un programma in stato di esecuzione.
\textbf{Come?} Fondamentalmente dati due processi, la socket è colei in grado di
metterli in comunicazione inviando o leggendo dati.
\section{Aspetti critici}
\subsection{Gestione del ciclo di vita di client e server}
Quando si attiva e/o disattiva uno dei due, chi la gestisce è il middleware, 
oppure può essere manuale
\subsection{Identificazione ed accesso al server}
Un client per accedere ad un server deve conoscerne l'indirizzo ed una serie di
informazioni che consentano di raggiungerlo.
\paragraph{Come fa un client a conoscere l'indirizzo server?} Ha diverse alternative
\begin{itemize}
	\item Inserisce nel codice del client l'indirizzo del server espresso
	come costante (Il client di un servizio bancario)
	\item Si chiede all'utente di inserire l'indirizzo (E' quello tipico di 
	browser e simili)
	\item Si può utilizzare un \textbf{name server} o si attinge da un repository
	da cui il client può acquisire informazioni necessarie
	\item Si adotta un protocollo differente per individuare il server (ad 
	esempio il DHCP)
\end{itemize}
\subsection{Comunicazione client server}
Quali sono le primitive disponibili? Quali sono le modalità di comunicazione?
\subsection{Ripartizione dei compiti client e server}
Dipendentemente dal tipo di applicazione si decide chi fa cosa, quali compiti
spettano al server, quali al client. Come si decide? Si deve fare un'analisi
dei rischi in fatto di sicurezza, prestazioni etc.
\section{Soluzioni agli aspetti critici}
\begin{enumerate}
	\item Si identifica la controparte, tramite il naming, ogni host avrà un nome,
	si fa riferimento ad un indirizzo ed una porta
	\item Per accedere alla controparte servirà accedere all'indirizzo:porta,
	usando direttamente l'indirizzo IP (access point)
	\item Comunicazione 1: (Protocolli) Stream di byte
	\item Comunicazione 2: (Sintassi e semantica) Metodo di interpretazione dei 
	flussi di byte 
\end{enumerate}
Il livello di trasparenza è basso poichè è il programmatore che deve preoccuparsi
di queste problematiche
\section{Comunicazione via socket}
Le comunicazioni in TCP/IP avvengono tramite flussi di byte in seguito ad una
connessione esplicita con systemcall read/write
\paragraph{Perchè?} Perchè sono due funzioni sospensive, ovvero bloccano il processo
finchè non è raggiunto il completamento dell'operazione e soprattutto viene
utilizzato un buffer per garantire flessibilità
\paragraph{Come funziona?}
\begin{enumerate}
	\item Il server richiede di aprire un canale in ascolto (Socket bind)
	\item Il client con una socket crea un canale analogo, senza una bind, ma 
	con stesso effetto finale
	\item Il client invia la richiesta, il cui formato è stabilito dal livello
	di trasporto
	\item Il server crea un secondo canale di comunicazione che sarebbe l'accept,
	quindi avviene l'handshake, poi si procede con il trasferimento
\end{enumerate}
Non si comunica sulla stessa socket poichè da una socket o si entra o si esce,
non si possono fare entrambe le cose.
\chapter{Tipi di comunicazione}
Ci sono fondamentalmente diversi tipi di comunicazione. Il primo tipo è la 
comunicazione orientata ai messaggi. Per capire meglio come funzioni quest'ultima
si fa riferimento all'architettura del Web, ma prima definiamo la comunicazione
orientata ai messaggi.
\section{Comunicazione orientata ai messaggi}
Come accennato prima, questo tipo di comunicazione prevede lo scambio di messaggi,
generalmente uno richiesta e uno risposta, ed è tutto gestito e controllato da 
dei protocolli.
\subsection{Protocolli}
Un protocollo è un insieme di regole atte a stabilire formato, ordine di invio e
ricezione, dispositivi, tipi per i dati ed azioni da eseguire in invio e ricezione
di un messaggio
\paragraph{Alcuni esempi di protocolli:} HTTP, SFTP, SMTP, FTP, verranno definiti
in seguito.
\subsection{Protocollo HTTP}
Il web (dopo si vedrà come) lavora prevalentemente con HTTP (hypertext transfer
protocol), quindi tramite 
scambio di HTTP requests e responses tra client e server, è fondamentalmente
il protocollo in grado di trasferire dell'ipertesto.
\paragraph{Cosa c'è alla base di HTTP?} Livello transport: TCP, nello specifico
instanzia una socket sulla porta 80, il server accetta la connessione (Handshake
a 3 vie) e si effettuano gli scambi
\paragraph{E' un protocollo stateless: } Il server non si ricorda delle richieste
precedenti, quindi una richiesta deve avere tutte le informazioni richieste per
l'esecuzione. Ci sono altri protocolli che mantengono però l'informazione.
\paragraph{Formato dei messaggi HTTP: } Request e response hanno la stessa
struttura: 
\begin{center}
\includegraphics[width=0.75\textwidth]{2}
\end{center}
\paragraph{Esempio di messaggio HTTP request:}
\begin{center}
\includegraphics[width=0.75\textwidth]{3}
\end{center}
\subsection{Metodi per effettuare HTTP requests}
Sono fondamentalmente 3:
\paragraph{Metodo GET:} Restituisce una rappresentazione di una risorsa, include
un eventuale input in coda alla URL della risorsa, l'esecuzione non ha effetti sul server
ed è gestible da una cache del client
\subparagraph{Specificazione: }Una get può essere condizionale, per evitare di 
inviare roba che il client ha già nella cache. Ad esempio ci puoi mettere un
if-modified-since: data che banalmente non trasferisce nulla se l'ultima modifica
è entro una certa data. 
\subparagraph{E la risposta?} Il server dà risposta vuota se l'oggetto è aggiornato.
HTTP/1.0 304 Not Modified 		
\subparagraph{Uso tipico:} Ottenere dati in formato di pagine html e immagini
\paragraph{Metodo POST:} Comunica dei dati che vengono elaborati lato SERVER o
crea una risorsa subordinatta all'URL, inoltre non è idempotente, ogni esecuzione
ha un effetto diverso, e la risposta non è gestibile con una cache lato client.
E' usata per gestire i FORM o modificare i DB
\paragraph{Metodo HEAD:} Molto simile alla GET ma restituisce solo l'HEAD della
pagina web, si usa spesso in fase di debug.
\paragraph{Ecco una tabella riassuntiva dei metodi HTTP:} 
\begin{center}
\includegraphics[width=0.75\textwidth]{4}
\end{center}	
\paragraph{Formato di una HTTP response:}
\begin{center}
\includegraphics[width=0.75\textwidth]{5}
\end{center}
\subsection{I tipi MIME}
Nella parte del web si vedrà una specificazione di questi, fodamentalmente 
MIME significa Multipurpose Internet Mail Extension, qualifica i dati
via Internet (in HTTP, qualifica il tipo dei dati del body)
\paragraph{Quali sono questi tipi? }Testo, immagini, video, audio, dati che devono
essere processati da un'applicazione prima di esser visibili
\subsection{I cookie}
Un cookie serve per legare più richieste in modo da associare un ID alla conversazione.
Il client manda al server un cookie, che è un numerello, ed il server saprà
chi è che parla ogni volta che riceve quel cookie per gli accessi positivi.
\paragraph{Come vien controllato? }Il server autentica ogni cookie, traccia
le preferenze dell'utente e la sessione di lavoro (Sì, esatto, quella roba dei
cookie che si legge in ogni sito serve a questo)
\paragraph{Come controllo l'accesso ai documenti lato server?} Consideriamo che
HTTP è stateless, il client deve autenticare ogni richiesta, perciò molto
semplicemente il client manda login e password nell'header del messaggio, e 
per evitarsi che l'utente li digiti ogni volta, se li salva. Not bad!
\section{Comunicazione orientata allo stream}
Questa cosa è stata menzionata nella parte relativa al livello di trasporto
del modello TCP/IP, fondamentalmente è la differenza tra TCP e UDP. TCP numera
ogni elemento della sequenza, garantisce la correttezza dell'informazione, 
l'ordine, e l'integrità. Invece UDP di questo non si cura.
\paragraph{E al lato applicativo? } L'applicazione invia i messaggi come stream 
di byte al livello di trasporto, e poi leggerà i byte dal trasporto ricostruendo
i messaggi. Ma non si cura di ciò che c'è sotto
\section{Architettura del web}
Il web supporta l'interazione tra client e server mediante HTTP, e a seconda del
fatto che un host sia client o server cambierà il tipo di messaggio che invia
(o riceve). 
\begin{itemize}
	\item Se si tratta di un \textbf{Server} riceverà delle HTTP \textbf{Requests}
	\item Se si tratta di un \textbf{Client} riceverà delle HTTP \textbf{Response}
\end{itemize}
Client e server sono rispettivamente rappresentati da:
\begin{itemize}
	\item Client: un Browser, od un User-Agent
	\item Server: un web server o HTTP server
\end{itemize}
\section{Tipi di comunicazione}
Esistono diversi tipi di comunicazione:
\begin{enumerate}
	\item Comunicazione sincrona o asincrona
	\item Comunicazione transiente (se il destinatario non c'è, i dati sono 
	scartati)
	\item Comunicazione persistente: Il middleware memorizza i dati fino alla consegna
	del messaggio, non serve che i processi siano in esecuzione prima e dopo l'invio.
\end{enumerate}
\subsection{Comunicazione persistente}
Un messaggio persistente può esser sia sincrono che asincrono, la differenza nel fatto che
nel caso dell'asincrono, dati A e B che voglion comunicare:
\begin{enumerate}
	\item A invia un messaggio e continua a fare il suo
	\item B si sveglia ad un certo punto, e riceve il messaggio
\end{enumerate}
Mentre nel caso il messaggio è sincrono
\begin{enumerate}
	\item A invia un messaggio a B e si ferma ad aspettare
	\item B non è in esecuzione ma il messaggio verrà salvato in un buffer
	che leggerà al risveglio
	\item A riceve l'ok dell'inserimento del dato in quel buffer, e torna a fare il suo
	\item B si sveglia, e riceve il messaggio
\end{enumerate}
Nel caso di una comunicazione asincrona transiente:
\begin{enumerate}
	\item A manda il messaggio e fa il suo
	\item B riceverà solo se è in esecuzione
\end{enumerate}
Nel caso invece la comunicazione è sincrona A invia e aspetta che b riceva e risponda.
Invece per le comunicazioni transienti delivery-based si ha che:
\begin{enumerate}
	\item A invia una richiesta e aspetta
	\item B si sta facendo i cazzi suoi da acceso, riceve, risponde con comodo
	\item A riparte da quando riceve l'accepted, e poi B processa la sua richiesta
\end{enumerate}
Invece nel caso sia una response-based..
\begin{enumerate}
	\item A invia il messaggio, e non solo aspetta che B risponda, ma aspetta
	che B finisca di processare, producendo un Sent-request delay.
\end{enumerate}
\subsection{Web browser}
Considerando il lato client si ha questo software che consente di visualizzare
le pagine web, è detto \textbf{User-Agent}, fondamentalmente ciò che fa un 
browser è \textbf{interpretare} un codice di mark up (HTML, ad esempio), che
sarebbe una pagina web, e successivamente visualizzarlo (in forma di ipertesto)
\paragraph{Mh.. Manca qualcosa:} Assieme all'HTML (che delinea la grafica) un
browser consente (soprattutto se $browser \neq Internet-Explorer$) molta più
roba, dalla multimedialità, ai feed RSS, ai file XML, Json etc. 
\subsection{La pagina web}
Come accennato nella sottosezione precedente, si hanno delle vere e proprie 
pagine web, che fondamentalmente sono dei file, dei documenti, costituiti da
un certo insieme di oggetti, o \textbf{risorse}.
\paragraph{Definizione di risorsa:} Una risorsa è una \textbf{sequenza di dati}
\textbf{identificata da un URL}, che per intenderci è un indirizzo univoco. 
Questo insieme di dati risiede su \textbf{memoria di massa} e quindi è per 
semplificarci la vita un \textbf{file}. 
\paragraph{Okay, che file abbiamo?} La maggior parte delle pagine web ha almeno
una riga di HTML (Hypertext Markup Language), anche solo per definire i contenuti
testuali e qualche elemento grafico
\paragraph{E il web server?} Il web server è l'applicativo che ha il compito di
gestire quei famosi file, e soprattutto che li rende disponibili ai client (Se
c'è un mondo dietro ai browser, per fare a gara tra quale è il migliore, c'è 
anche lato server. Sì.)
\subsection{L'URL}
Un URL (Uniform Resource Locator) identifica un oggetto nella rete, ma non è questo
il lato più importante
\paragraph{Un URL specifica il protocollo con cui si possono interpretare i dati}.
\paragraph{Come è composto?} E' composto da 5 componenti principali:
\begin{enumerate}
	\item Nome del protocollo (sftp, http, https, ftp, smtp etc.)
	\item Indirizzo dell'host (IP address)
	\item Porta di destinazione 
	\item Percorso file nell'host
	\item Risorsa
\end{enumerate}
\paragraph{Esempio: accedi in ftp a 192.168.50.5 al percorso /media/hdd e 
prendi il file prova.txt} ftp://192.168.50.5:21/media/hdd/prova.txt
\subsection{Ipertesto}
Per tre volte si è menzionato l'\textbf{ipertesto}, ma cosa sarebbe? Fondamentalmente
è un insieme di testi o pagine leggiili tramite un'interfaccia elettronica. 
Funzionano tramite hyperlink, o anche solo link.
\paragraph{E che fanno i link?} Costituiscono una rete raggiata, o incrociata di
informazioni organizzate su citeri paritetici o gerarchici (I menù, per capirci)
\subsection{Linguaggi del web}
I dati testuali si esprimono con linguaggi standard (HTML, XML e JSON),
rispettivamente descrivono: Struttura contenuti (HTML) e struttura dei dati (JSON, XML)
\paragraph{E i dati non testuali?} Esiste una tecnica di encoding detta MIME che
consente di definire il formato dei contenuti non testuali (video, audio, etc.)
\paragraph{Ma gli script?} Lasciati in disparte fin dal principio, questi 
sono essenziali, consentono la creazione di pagine web \textbf{dinamiche}.
Alcuni dei più famosi: VBScript, PHP, JavaScript, Adobe Flash etc.
\chapter{HTML, DOM, CSS, JAVASCRIPT}
Sono tutti linguaggi, sebbene non tutti dello stesso tipo. Di fatto Javascript è
un linguaggio di programmazione (In questo caso interpretato) mentre per quanto
riguarda HTML e CSS si fa riferimento a linguaggi di Markup
\section{Linguaggi di markup}
\paragraph{Cosa sono?} In modo semplificativo, sono linguaggi che dicono 
all'interprete come rappresentare graficamente un foglio, o una pagina (in questo
caso web). 
\paragraph{Solo per pagine web?} No, questo documento è stato scritto in LaTeX, 
che è un linguaggio di MarkUp per documenti PDF, però non è solo questa la differenza.
Infatti LaTeX è compilato, mentre HTML, Markdown e simili sono tutti interpretati.
\paragraph{Chi è l'interprete di HTML+CSS?} Qualsiasi browser, addirittura anche
Internet Explorer (Con un quarto d'ora di ritardo, ma c'è).
\subsection{HTML}
Hypertext Markup Language, per l'appunto, linguaggio di markup per strutturare contenuti
web (L'ipertesto). Quando si è di fronte ad una pagina web, 9/10 è scritta, o 
contiene, del codice in HTML
\subsection{CSS}
Cascading Style Sheets, è un linguaggio di supporto all'HTML che invece serve per
dare uno stile di presentazione ai contenuti, quindi fondamentalmente è tipo una
libreria di quelle che si importa in Java o C. Da solo non serve a niente, ma 
integrandolo con HTML, porta a pagine carine
\paragraph{Diversi stylesheet:} Ne esistono diversi, per l'appunto \\
\begin{itemize}
	\item L'autore della pagina in genere ne specifica uno, o anche più di uno
	\item Il browser ne ha uno solo, o un vero css, oppure uno simulato nel codice
	del browser
	\item Il lettore, l'utente del browser, ne può definire uno personale per
	modificare la propria esperienza d'uso.
\end{itemize}
\subsection{DOM}
Document Object Model, è un'interfaccia neutrale rispetto al linguaggio di programmazione,
è fondamentalmente quello che consente ad una pagina web di essere dinamica ed 
avere del codice sotto che funziona. Form, elenchi, quella roba lì.
\paragraph{Precisazioni:} Usare HTML e CSS serve per fare in modo che contenitore
e contenuto siano indipendenti l'un dall'altro, la separazione dei concetti infatti
è ormai d'obbligo in informatica, PERO' lo stile può avere un coupling, un legame
con il contenuto. \\ \\
Il browser infatti non è un lettore di pagine scritte in HTML e morta lì, ma è un
ambiente di sviluppo che fornisce un numero enorme di funzionalità. Se premete
su una qualunque pagina F12 capirete meglio il concetto.
\chapter{Servlet e Applicazioni Web}
Prima di capire cos'è una servlet serve dare una veloce spiegazione di come funziona
un'applicazione web. \\ \\
Come spiegato in qualche precedente capitolo, tutto è basato su un'architettura 
client-server, quindi ci sarà un Web Client (Browser) ed un web server (Apache
o simili).
\paragraph{Come si passa dal Web alle applicazioni?} Partendo dal fato che il web
supporta l'interazione tra client e server via HTTP, il server avrà un programma 
che si chiama Application Server (E' UN SOFTWARE, NON HARDWARE) che è caratterizzato
dal protocollo di interazione con il Web Server stesso. L'interazione con il client
è infatti tutta in HTTP.
\paragraph{Cosa accade lato server?} Ogni calcolo, ogni computazione, viene 
svolta dal server, e può avvenire sia da scriptini che da programmi compilati.
Nel caso di software compilati ciò che accade è che il server invoca l'eseguibile
(Partendo dalla richiesta del client). 
\paragraph{Come vengono eseguiti gli script?} Il Web Server ha un motore in grado
di intepretare il linguaggio di scripting di riferimento, quello richiesto, per intenderci
\section{Sigle da sapere}
\begin{enumerate}
	\item URL: Uniform resource locator, definisce un naming globale, un modo per 
	tracciare le cose
	\item CGI: Content Gateway Interface, permette al server di attivare un 
	programma, passargli le richieste e i parametri dal client, e recuperare 
	una risposta
	\paragraph{Che vantaggi ci sono?}
	\begin{itemize}
		\item Ti devi programmare solo le logiche
		\item Hai un modello di applicazioni conformi al modello del linguaggio
		\item Semplice, riproducibile ovunque, manutenibile in modo agevole
	\end{itemize}
	\section{Servlet}
	Finalmente si arriva alle Servlet. Che sono? Sono applicazioni Java che si 
	trovano sul server. E' un componente che il server gestisce in modo automatico
	da un engine, oppure da un container. 
	Dalle slide c'era qualche esempio di come si costruiscono e usano, di 
	importante c'è solo da tenere a mente che:
	\begin{enumerate}
		\item Sono componenti gestite da un container o un engine
		\item Hanno un'interfaccia che definisce i metodi ridefinibili (Per
		esigenze di standardizzazione)
		\item Risiedono in memoria, mantenendo uno stato e possono interagire
		con altre Servlet
		\item HTTP non consente di mantenere un'informazione da un messaggio ai
		successivi, quindi questo lo fa la Servlet con Cookies e HTTPSessions
	\end{enumerate}
\end{enumerate}
\section{Cosa implementa l'interfaccia javax.servlet.Servlet}
\begin{center}
\includegraphics[width=0.75\textwidth]{6}
\end{center}
Sono presenti comunque due classi astratte che implementano questi metodi
in modo che non facciano nulla:
\begin{enumerate}
	\item javax.servlet.GenericServlet\\
	Praticamente implementa \textbf{service} che invoca i metodi per gestire
	le richieste dal web:
	\begin{itemize}
		\item doX con X che è un metodo HTTP (doGet, doPost)
		\item Parametri: HTTPServletRequest e HTTPServletResponse
		\item Eccezioni: ServletException e IOException
	\end{itemize}
	\item javax.servlet.http.HTTPServlet
\end{enumerate}
Anche i parametri sono stati adattati al protocollo HTTP, cioè consentono di
ricevere(inviare) messaggi HTTP leggendo(scrivendo) i dati nell’head e nel
body di un messaggio.
\begin{enumerate}
	\item HTTPServletRequest
	\begin{itemize}
		\item Viene passato un oggetto da \textbf{service}
		\item Contiene la richiesta di un client
		\item E' un'estensione di ServletRequest
	\end{itemize}
	\item HTTPServletResponse
	\begin{itemize}
		\item Viene passato un oggetto anche qua da \textbf{service}
		\item condiene però la risposta PER il client
		\item Estende (manco a dirlo) ServletResponse
	\end{itemize}
\end{enumerate}
\subsection{Metodi per richieste e risposte}
\begin{center}
\includegraphics[width=0.75\textwidth]{7}
\end{center}
Poi ci sono altri metodi legati ai cookies:
\begin{center}
\includegraphics[width=0.75\textwidth]{8}
\end{center}
\section{Come si esegue una servlet}
Tutto parte da un HTTPServer e un Servlet container che per l'appunto contiene
la Servlet (In memoria, come specificato nella sezione precedente).
Semplicemente viene creata un'istanza della servlet condivisa da tutti i
client, ed ogni richiesta genera un nuovo Thread che esegue doX in base a 
cosa è stato richiesto.
\subsection{Ciclo di vita}
\begin{enumerate}
	\item Dal container si crea la Servlet
	\item Si invoca il metodo init() per inizializzazioni specifiche
	\item Una servlet viene distrutta all'occorrenza di uno o due eventi:
	\begin{enumerate}
		\item Quando non ci sono servizi in esecuzione
		\item Quando è scaduto un timeout predefinito
	\end{enumerate}
	\item Si invoca il metodo destroy() che termina la servlet e ne dealloca
	le risorse.
	\paragraph{Principali problemi:}
	\begin{enumerate}
		\item Container e richieste devono sincronizzarsi sulla terminazione
		poichè alla scadenza di un timeout magari la service() è ancora in
		esecuzione e quindi
		\begin{enumerate}
			\item Bisogna tener traccia dei Thread in esecuzione
			\item Bisogna progettare il metodo destroy() in modo da notificare
			gli shutdown ed attendere il completamento di service()
			\item Bisogna progettare metodi lunghi in modo che si verifichi
			periodicamente se è in corso uno shutdown
		\end{enumerate}
	\end{enumerate}
\end{enumerate}
\section{JSP: Java Server Pages}
E' una tecnologia per creare applicazioni web.
Specifica l'interazione tra un container ed un insieme di pagine che l'utente
avrà davanti.
\paragraph{Perchè?} Perchè rispetto alle servlet, facilitano la separazione
tra logica applicativa e presentazione\\ \\
In pratica servono a separare la parte dinamica dal codice statico HTML
infatti il codice si racchiude tra "<\%" e "\%>". La pagina viene convertita
automaticametne in una servlet java la prima volta che vien richiesta
\subsection{Ciclo di vita di una applicazione JSP}
\begin{enumerate}
	\item Il client manda una richiesta al WebServer
	\item Il webserver contatta il Servlet Container
	\item Dal Servlet Container si richiama una JSP che compila la Servlet
	con il JSP compiler, e infine, viene eseguita la Servlet dal Servlet
	container
\end{enumerate}
\subsection{Elementi di una JSP}
\begin{center}
\includegraphics[width=0.75\textwidth]{9}
\end{center}
\begin{center}
\includegraphics[width=0.75\textwidth]{10}
\end{center}
\subsection{Azioni di una JSP}
\begin{center}
\includegraphics[width=0.75\textwidth]{11}
\end{center}
\subsection{Elementi di scripting}
\begin{center}
\includegraphics[width=0.75\textwidth]{12}
\end{center}
\begin{center}
\includegraphics[width=0.75\textwidth]{13}
\end{center}
\subsection{Oggetti e loro "scope"}
\begin{center}
\includegraphics[width=0.75\textwidth]{14}
\end{center}
\begin{center}
\includegraphics[width=0.75\textwidth]{15}
\end{center}
\section{Pattern Model View Control}
Il pattern Model View Controller (Da ora solo MVC) serve per
\begin{itemize}
	\item Separare i dati ed i metodi per manipolarli (Model)
	\item Curare l'interfaccia, come si presenta graficamente (View)
	\item Regolare il coordinamento dell'interazione tra interfaccia (quindi
	le azioni degli utenti) ed i dati (Controller)
\end{itemize}
Il tutto secondo questo schema:
\begin{center}
\includegraphics[width=0.75\textwidth]{16}
\end{center}
\section{Remote Procedure Call}
Il RPC è un modello che si applica al client-server, come se fosse una vera
e propria maschera. Se esiste è perchè ci sono dei vantaggi, ovvero una
semantica nota (chiamata di procedura) e perchè si semplifica l'implementazione.
\paragraph{E gli svantaggi?} Sono realizzate dal programmatore, quindi tutto
è esplicito (basta usare modelli con componenti più complesse). Inoltre sono 
\textbf{Statiche}, scritte direttamente nel codice dei programmi e non c'è
concorrenza, quindi son bloccanti. O loro, o nessuno. 
\paragraph{Tenendo a mente i modelli di comunicazione tra client e server,}
questo è ciò che accade con il modello RPC asincrono. 
\begin{center}
\includegraphics[width=0.75\textwidth]{17}
\end{center}
E come si passa da PC a RPC?
\begin{center}
\includegraphics[width=0.75\textwidth]{18}
\end{center}
\section{RMI: Distributed Objects}
Partiamo con il considerare l'architettura di riferimento
\begin{center}
\includegraphics[width=0.75\textwidth]{19}
\end{center}
La quale presenta delle sue caratteristiche
\begin{center}
\includegraphics[width=0.75\textwidth]{20}
\end{center}
\subsection{Puntatori e riferimenti}
\paragraph{Un puntatore} è un tipo per i dati le cui variabili contengono un indirizzo
di memoria (Variabile di tipo puntatore, per accorciare una variabile di tipo
puntatore è chiamata solo puntatore). \\ \\
Può essere modificato in qualsiasi istante e non dipende dal tipo per i dati
della variabile puntata.
\paragraph{Un riferimento,} o anche solo reference in Java, è una variabile 
che contiene delle infdormazioni logiche (alias) per accedere ad un oggetto,
è \textbf{immutabile} e dipendente dalla classe, nel senso che la classe 
dell'oggetto ne definisce il tipo.
\paragraph{Ha senso parlare di puntatore distribuito?} No, non avrebbe praticamente
senso
\paragraph{Invece una reference distribuita?} Sì, presenta un indirizzo della
macchina + indirizzo (porta) del server (processo) e soprattutto un \textbf{ID}
dell'oggetto stesso
\section{RMI Middleware}
Tutto questo preambolo per dire che RMI è un middleware, che estende l'approccio
\textbf{OO} al distribuito
\begin{itemize}
	\item Supporta anche l'invocazione di metodi tra oggetti su macchine 
	virtuali distinte
	\begin{itemize}
		\item Le interfacce sono Java, non in un IDL generico
		\item Vengono passati e tornati oggetti Java
		\item Le classi vengono caricate dinamicamente
	\end{itemize}
	\item Si basa sulla portabilità del bytecode e sulla macchina virtuale:
	quindi è più \textbf{sicuro} ed \textbf{efficiente} perchè non si deve
	tradurre nulla.
	\item Inoltre fornisce alcuni servizi:
	\begin{itemize}
		\item Caricamentoe controllo con un class loader e un security manager
		\item Gestione di oggetti remoti, replicati e persistenti
		\item Attivazione automatica degli oggetti e multithreading
		\item Garbage collection di oggetti remoti con un meccanismo di conteggio
		delle reference
	\end{itemize}
\end{itemize}
\subsection{Trasferimento dei parametri}
Qualsiasi tipo primitivo è passato per valore, insieme agli oggetti non remoti
\color{red}\textbf{SOLO SE SERIALIZZABILI}\color{black}
\paragraph{Esiste anche trasferimento per reference?} Sì, i riferimenti ad 
oggetto remoto sono passati per valore per permettere invocazioni remote. 
In particolare:
\begin{enumerate}
	\item La classe \textbf{java.rmi.server.UnicastRemoteObject} è una reference class
	fatta apposta per lo scopo
	\item Implementa le interfacce Remote e Serializable
\end{enumerate}
Sì ok, però si parla da entrambe le parti di passaggio per valore.. Perchè?
Tutto merito della serializzazione
\subsection{Concetto di serializzazione}
E' molto semplicemente la conversione di un oggetto, un dato, un valore, in una
sequenza di 0 ed 1, un flusso, da un oggetto ad un flusso. Il processo inverso
è chiamato \textbf{deserializzazione}, o anche noto come \textbf{casting}. 
Ricevi un flusso, gli dai una forma, fine.
\paragraph{A che serve?} In rete qualsiasi cosa è passata serializzata, ma
occorre che si definiscano degli oggetti persistenti. \\ \\
Il meccanismo di loafding dinamico di Java permette di passare solo le info 
essenziali sullo stato, infatti la \textbf{descrizione della classe} può
essere caricata a parte.
\paragraph{I tipi base sono serializzabili in modo nativo,} mentre per classi 
più complesse serve implementare l'interfaccia \textbf{Serializable}, che ti
fa ridefinire 
\begin{enumerate}
	\item private void writeObject(java.io.ObjectOutputStream out) throws IOException;
	\item private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;
\end{enumerate}
\subsection{Identificazione degli oggetti}
Come può una macchina A ricevere la reference remota dell'oggetto remoto O2?
\begin{center}
\includegraphics[width=0.75\textwidth]{21}
\end{center}
\begin{enumerate}
	\item Prima di tutto usando nomi assegnati dall'utente e un 
	\textbf{directory service} per convertirli in \textbf{reference operative}
	\item I \textbf{directory service} oppure anche \textbf{naming service} devono
	essere disponibili ad un host e porta noti (well-known addresses)
	\item Infatti a questo scopo RMI definisce un \textbf{rmuregistry} che
	sta su ogni macchina che ospita oggetti remoti (per convenzione sulla porta
	1099)
	\item RMI attiva un servizio di ascolto.. per quel servizio (Sorry per la
	ripetizione, non so in che altro modo possa dirlo)
\end{enumerate}
Esiste quindi una classe Naming? Sì esatto, e dà diretto accesso alle funzionalità dei
RMI Registry
\subsection{Architettura in dettaglio}
\begin{center}
\includegraphics[width=0.75\textwidth]{22}
\end{center}
\chapter{Ajax - Javascript}
\section{Architettura Multitier}
Riprendendo cos'è l'architettura multi-layer, qui fondamentalmente si parla di
applicazioni composte da più componenti che collaborano per eseguire un compito.\\ \\
Prendiamo una tipica scomposizione in 3 livelli:
\begin{center}
\includegraphics[width=0.75\textwidth]{23}
\end{center}
In un'applicazione scomposta su questi 3 livelli, la parte business agisce come 
server per la presentation, mentre agisce come client per la componente data
\section{RIA - Rich Internet Application}
\paragraph{Quali sono le caratteristiche del web?}
\begin{enumerate}
	\item Le pagine web si \textbf{ricaricano} e non \textbf{aggiornano}
	\item Gli utenti aspettano che si carichi l'intera pagina anche se serve
	solo un dato
	\item Si hanno restrizioni su singole request/response
\end{enumerate}
\paragraph{Ajax, da titolo, che cos'è?} E' una tecnica di sviluppo per creare
delle applicazioni web interattive (in senso di pattern programmativo).
\textbf{Ajax} sta per: \textbf{Asynchronous Javascript and XML}, quindi
\begin{itemize}
	\item Asynchronous: rende asincrona la comunicazione tra browser e web server
	\item Javascript: E' il cuore del codice tramite cui funzionano le applicazioni
	Ajax, ed è di supporto per la comunicazione con applicazioni server
	\item XML: è solo usato per trasferire i dati per costruire pagine web identificando
	i campi per il successivo uso nel resto dell'applicazione (Json è il più
	comune)
	\item DOM: Utilizzato tramite JavaScript per manipolare sia la struttura della 
	pagina HTML che le risposte XML del server
\end{itemize}
\paragraph{Quali sono le componenti?}
\begin{itemize}
	\item 
\end{itemize}
\paragraph{C'entra qualcosa il web 2.0?} Sì, se no non lo menzionavo. Il web
2.0 fa sì che il web diventi una piattaforma, in cui l'esperienza utente è ricca,
ed il contenuto viene direttamente dall'utente stesso (con la nascita dei forum)
\paragraph{Okay, qualche esempio di uso dell'Ajax?}
\begin{enumerate}
	\item Form validati in corso di compilazione
	\item Autocompletamento dei campi dei form
	\item Controlli UI sofisticati 
\end{enumerate}
\paragraph{Componenti Ajax}
\begin{itemize}
	\item HTML
	\item DOM
	\item XML e XSLT
	\item Oggetto XMLHttpRequest
	\item Javascript
\end{itemize}
\subsection{Architettura web classica}
\begin{center}
\includegraphics[width=0.75\textwidth]{25}
\end{center}
\subsection{Architettura web dinamica}
\begin{center}
\includegraphics[width=0.75\textwidth]{26}
\end{center}
\subsection{Applicazioni web e Ajax}
\begin{center}
\includegraphics[width=0.75\textwidth]{27}
\end{center}
\subsection{Processo request}
\begin{center}
\includegraphics[width=0.75\textwidth]{28}
\end{center}
\subsection{Principali problemi}
\begin{enumerate}
	\item Rottura del tasto back dei browser, poichè ci sono degli IFrames che
	possono invocare cambiamenti in grado di modificare la cronologia
	\item Cambiamenti di alcune parti della pagina inaspettate
	\item L'aggiunta ai segnalibri di un determinato stato risulta difficoltosa,
	perchè JS genera la pagina, NON il server
	\item L'incremento della dimensione, o lunghezza del codice ha un brutto 
	impatto sui tempi di caricamento del browser, ed i tempi di risposta si
	dilatano
	\item Difficile da debuggare
	\item La sorgente è visualizzabile, quindi il plagio è estremamente facile
	\item Il server si fa carico del lavoro, poichè una richiesta anonima è 
	pesante da gestire
\end{enumerate}
\subsection{Trasmissione dei dati}
La trasmissione dei dati tra server e applicazioni RIA è un aspetto critico, 
infatti esistono diverse alternative:
\begin{enumerate}
	\item SOAP (Simple Object Access Protocol)
	\item XML-RPC (Remote Precedure Call con XML per l'encoding)
	\item JSON (Javascript Object Notation)
	\item AMF (Action Message Format, basasto su SOAP)
\end{enumerate}
La scelta del formato avrà influenza sulle performance e sulla struttura dell'applicativo
inoltre un formato richiede del tempo per
\begin{enumerate}
	\item Predisporre i dati lato server
	\item Trasferire i dati
	\item Effettuare il parsing dei dati
	\item Effettuare il rendering dell'interfaccia stessa
\end{enumerate}
\section{Javascript}
Forse è già stato detto, ma va ripetuto cos'è un linguaggio di scripting, ossia
un linguaggio per l'automazione di compiti eseguibili da un utente umano 
all'interno di un ambiente software. Per ogni dominio di applicazione c'è un 
linguaggio praticamente, anche qui esistono i \textbf{general purpose} come
Python, e per l'appunto Javascript.
\paragraph{Caratteristiche tipiche}
\begin{enumerate}
	\item Semplicità
	\item Specificità
	\item Intepretazione (Non è codice compilato, ma sempre interpretato)
\end{enumerate}
LISP (nella variante AutoLISP) è attualmente incluso in AutoCAD, quindi 
AutoCAD è un simulatore di parentesi, mica male! Ed in tutto questo, Javascript?
E' un linguaggio pensato per eseguire script in un browser web \textbf{lato client}
, e soprattutto per l'interazione con l'utente, validazione dei dati nei form etc.
\paragraph{JS è dinamico, fortemente tipizzato e con una sintassi simile a Java e
C,} che tra l'altro questa affermazione è ricorsiva, perchè Java stesso è simile a C.
Per vedere come funziona Javascript c'è \href{https://www.w3schools.com/js/}{W3Schools}, 
è il meglio.
Quello che ci interessa di nuovo è il jQuery.
\paragraph{Per giochicchiare con Javascript andate su} 
\href{https://jsfiddle.net/gvizzari/wup42mox/4/}{JSFiddle}
\section{jQuery}
E' un framework JavaScript che rende più semplice la scrittura di applicazioni
web offrendo diverse funzionalità. 
\begin{enumerate}
	\item Manipolazione HTML/DOM e CSS
	\item Metodi per eventi HTML
	\item Effetti e animazioni
	\item Supporto per AJAX
	\item Plugins vari
\end{enumerate}
Essendo il più utilizzato manutenuto e testato si è deciso di usare questo, soprattutto
perchè è Open, compatto ed estendibile. 
\subsection{Elementi base di jQuery}
La sintassi è specificamente orientata a permettere una rapida selezione di elementi
del documento HTML, di base un comando si fa con:
\$(selector).action() \\ \\
In cui il \$ definisce l'accesso a funzioni jQuery \\ \\
Selector è usato per specificare una query per selezionare una parte del documento
HTML mentre action.. Beh è ciò che viene eseguito sull'elemento stesso.
\\ \\
Menzione speciale per la porzione: \\ \\
\$(document).ready(function()){
	[...]
}); // end ready \\ \\
Praticamente indica che vogliamo effettuare l'azione \textbf{ready} sull'oggetto
\textbf{document} passando come parametro una funzione anonima, specificata per 
esteso\\ \\
L'azione ready invece specifica che il parametro ricevuto, una funzione, va
ad essere richiamata quando il documento è 'pronto', ovvero caricato completamente.
\paragraph{Altri elementi utili:}
\begin{itemize}
	\item Ciò che vogliamo fare è selezionare le porzioni di documento presenti 
	ad esempio negli span di classe pq, clonarli dando allo steso tempo lo stile desiderato
	\paragraph{Il codice risulterà così:}
	\$('span.pq').each(function(){
	[...]
	}) //end each
	\item Praticamente specifichi una funzione anonima che si applica ad ogni span
	di classe pq, tipo quelle che si scrivevano in LISP, le lambda
\end{itemize}
\chapter{Concorrenza in Java}
Cosa significa che un software è concorrente? Molto semplicemente che ha diversi
controlli di flusso in contemporanea, cioè lo stesso software ha più esecuzioni
in contemporanea. Alcune funzioni ricorsive se effettuate con i Thread possono
risolvere il problema molto prima.. O riempirvi subito tutta la memoria.
\section{Perchè software concorrenti?}
Perchè si sfruttano i sistemi multi-core, e perchè si divide il carico di lavoro,
facendo in modo che si esegua più velocemente. Una task che con un core ci 
impiega 10, con 2 core ne impiega 5, e così via. \textbf{Ma non solo.}
\paragraph{Un altro motivo è} il fatto che in questo modo se si dovesse bloccare
uno dei thread, non crasha tutto l'intero software (questo dimostra che la UI è
un thread scollegato da ciò che sta sotto)
\paragraph{Ultimo ma non ultimo:} Per strutturare il programma in modo più adeguato,
in particolare programmi che hanno diverse cose da tenere sotto controllo, che gestiscano
diversi tipi di eventi (Tipo Overwatch, per ogni giocatore ci sarà sotto un Thread),
per ogni countdown degli oggetti etc.
\paragraph{Come vengono visti dal sistema operativo?} I processi non condividono
risorse tra loro, a parte l'esecuzione dalla stessa CPU, ma a questo punto per 
comunicare devono usare file, syscall, servizi, o middleware etc., inoltre i
thread di uno stesso processo condividono stesso spazio di indirizzamento e oggetti
in memoria. Non mi sto a dilungare su come si facciano i Thread in java, vi basti
sapere che ci son due modi. 
\begin{enumerate}
	\item Implementazione dell'interfaccia Runnable
	\item Estensione della classe Thread
\end{enumerate}
Sono praticamente la stessa cosa, son due metodi equivalenti.
\section{Problemi della concorrenza}
Avere più processi che operano con le stesse risorse potrebbe rivelarsi un 
problema, e non indifferente. In primo luogo c'è il problema delle risorse condivise.
\subsection{Problema di accesso a risorse condivise}
Ipotizziamo di avere due processi che operano sulla stessa variabile, potrebbero
avvenire modifiche sbagliate, o uno dei processi potrebbe riscontrare un'incongruenza,
quindi si genera un problema di consistenza di quella variabile.
\paragraph{A cosa è dovuto il problema?}
Quando le operazioni sulla variabile non sono atomiche, diventano interrompibili
anche a metà della loro esecuzione, questo causa il problema di prima. Come si risolve?
\textbf{Mutua Esclusione}
\subsection{Mutua esclusione}
Il concetto è questo: per mutua esclusiva, se utilizzo una risorsa, io processo 
sarò l'unico ad utilizzarla fino a fine esecuzione. Come lo posso fare? con
la keyword \textbf{synchronized} che letteralmente si occupa di fare questo, 
poichè Java associa un intrinsic lock ad ogni oggetto che abbia almeno un metodo
synchronized.
\paragraph{Direttamente da Repl.it c'è} \href{https://repl.it/@gvizzari/ContoCorrente-sync}
{Questo esempio proposto direttamente
dal Vizzari}. (Se non dovesse esserci, ci sarà un file.java dentro la cartella di
SD)




































\end{document}