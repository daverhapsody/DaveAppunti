\documentclass[12pt, a4paper, openany, oneside]{book}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath} 
\usepackage{xcolor}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{amssymb}
\graphicspath{{./img/}}
\hypersetup{
colorlinks=true,
linkcolor=blue,
filecolor=magenta,      
urlcolor=cyan,
}
%usepackage[latin1]{inputenc}
\begin{document}
\fontfamily{cmss}\selectfont
\pagestyle{plain}
\author{DaveRhapsody}
\title{Linguaggi e Computabilità}
\date{2 Ottobre 2019}
\maketitle
\tableofcontents
\chapter{L'esame}
Avremo due compitini, uno a novembre ed uno a Gennaio, in un anno sono 
disponibili 5 appelli, se uno è del terzo anno, può fare i compitini, basta che
ci sia spazio nelle aule, la precedenza va a coloro che sono del secondo anno.
\\ \\
Al secondo appello (Quello di Febbraio) puoi recuperare il voto negativo di uno
dei due compitini. Non presentarsi è esattamente come provarci e non passare, 
quindi rischiate, conviene.
\\ \\ 
L'orale va sostenuto nello stesso appello dello scritto, cioè io faccio lo 
scritto, lo passo, l'orale lo devo fare in quella sessione.
Per chi fa i compitini ed ha consegnato anche gli esercizi di lab. può fare un
orale prima del 5 Febbraio OPPURE si può fare assieme a coloro che hanno fatto
l'esame il 5.
\\ \\
Gli esercizi valgono dal momento che li invii fino a fine anno, quindi ha senso
farli subito tutti
\\
{\color{black} \rule{\linewidth}{0.3mm} }
\\
\chapter{Linguaggi formali}
Nascono per essere in grado di creare i linguaggi di programmazione, o meglio
servono per gestire i protocolli di comunicazione e la possibilità di comunicare
una determinata operazione al calcolatore.
\section{Backus-naur form (Backus Normal Form)}
\paragraph{Definizione}Da 
\href{https://it.wikipedia.org/wiki/Backus-Naur_Form}{Wikipedia}:
è una metasintassi, ovvero un formalismo attraverso cui è possibile descrivere 
la sintassi di linguaggi formali (il prefisso meta ha proprio a che vedere con 
la natura circolare di questa definizione). Si tratta di uno strumento molto 
usato per descrivere in modo preciso e non ambiguo la sintassi dei linguaggi di
programmazione, dei protocolli di rete e così via, benché non manchino in 
letteratura esempi di sue applicazioni a contesti anche non informatici e 
addirittura non tecnologici. La BNF viene usata nella maggior parte dei testi 
sulla teoria dei linguaggi di programmazione e in molti testi introduttivi su
specifici linguaggi.  
\section{Model checking}
Usato per protocolli di comunicazione, per esempio per protocolli di pagamento,
in realtà di qualsiasi tipo, chiaramente per la sicurezza questo è l'ideale, 
perchè si descrive lo stato di sistema, e si specifica se ogni stato è sicuro
(Sicuro sia dal punto di vista dei risultati corretti che sicuri)
\\ \\
E' usato anche per il software, cioè in maniera automatica deduce in base alle
condizioni di ingresso, se son corrette. Ce la fa? Si per programmi piccini, 
ma alla fine, ma ingenerale, non esiste una tecnica che preso un software ti 
dimostra che esso sia corretto in ogni caso. Non esiste nessuna procedura generale,
se esistesse ci sarebbero contraddizioni logiche.
\paragraph{Cos'è una contraddizione logica?} 
E' un paradosso, ma a livello un po' più infame, pensate alla frase "Questa 
frase è vera", se ci scavate a fondo, dopo un po' diventa una contraddizione.
\section{Automi a stati finiti}
Sono insiemi di stati ai quali arrivan dall'esterno dei dati, ed a seconda dello
stato in cui si trovano, e del dato che arriva, allora potrebbero verificarsi le
famose "Transizioni" che consistono nel cambiare stato.
\\ \\ 
La memoria del Latch SR, ad esempio, funziona come un automa, nel senso, varia
a seconda dello stato interno, e del valore di ingresso.
\\ \\
\paragraph{Linguaggio Per} E' uno dei primi linguaggi di scripting, anche se ce 
n'era qualcun altro prima, e contiene istruzioni per gestire espressioni regolari
che possono essere applicate su testi lunghi per fare ricerche.\\ 
In pratica prendevano delle sequenze di DNA (tera di dati), e venivano analizzati
(con espressioni regolari) da questo linguaggio.
\chapter{Alfabeto}
E' un insieme finito e non vuoto di simboli, ad esempio:
\{A, B, C, D, ... , Z\} , \{1, 2, 3, 4, ..., 9\}. \\ 
Per gli alfabeti useremo lettere greche tipo: $\Sigma, \Lambda, \Gamma$, vediamo
alcune definizioni ora:
\paragraph{Stringa} La stringa è una sequenza di simboli, se è 
vuota si definisce vuota, può esistere. \\ Data una stringa w, si indica la sua
lunghezza con |w|. Per esempio: |acdas234| = 8, mentre se ho |$\epsilon$| = 0,
poichè si indica che una stringa è vuota dicendo che essa abbia solo una lettera
greca dentro
\paragraph{Concatenazione tra stringhe}
La concatenazione fa in modo che date due stringhe w, x l'ultimo carattere di x
sarà il successivo dell'ultimo di w. pertanto, w, x $\to$ w $\circ$ x = wx \\
Per esempio se ho una stringa vuota, e la concateno ad una stringa, otterrò la
stringa (3+0 fa 0, no? :)) $\to \epsilon \circ $ w = w \\ \\
Chiaramente si vanno a sommare le lunghezze delle due stringhe in ogni caso. 
\subparagraph{NON Commutatività di una stringa}
Concatenare due stringhe non è sempre possibile, a meno che siano perfettamente
identiche
\paragraph{Potenze di un alfabeto} 
Prendiamo un alfabeto $\Sigma$ e per un k intero >= 0 $\Sigma ^{k} = \Sigma x, 
\Sigma x, \Sigma x, \Sigma x$, ottengo una permutazione di k volte $\Sigma$, tutte
appartenenti a $\Sigma ^{k}$ \\ \\
Come sarà la sua cardinalità? |$\Sigma$| = q $\to$  |$\Sigma ^{k}| - q^{k}$.
\\ \\ 
Per k = 1 avrei $\Sigma ^{1}$ w = qualsiasi elemento di $\Sigma$(un solo elemento) 
\\ \\
Se ho $\Sigma$ = {0, 1} \\
$\Sigma ^{2}$ = Tutte le permutazioni che posso fare con 0, 1 \textbf{i lunghezza 2}
(I valori di $\Sigma$)
\\ \\
Per definizione $\Sigma ^{0}$ = {$\epsilon$}, \\
\subparagraph{Attenzione} Quello che è contenuto in $\Sigma$ è un insieme di STRINGHE
non caratteri o simboli. 
\paragraph{Chiusura di Kleene}
$\Sigma ^{*}$ = U per k $\geq$ 0 $\Sigma ^{*}$ = U per k $\in$ {0 ad $\infty$}
di $\Sigma ^{k}$
\\ \\
$\Sigma ^{+}$ = $\Sigma ^{*} - \Sigma ^{0}$, invece $\Sigma ^{*}$ è considerabile
come $\Sigma ^{+} \cup \Sigma ^{0}$
\paragraph{ATTENZIONE} La L che userò nei prossimi passaggi ($\to L$) è una MACCHINA 
AUTONOMA che verifica la stringa in questione
\paragraph{Linguaggio L su $\Sigma$}
E' un sotto insieme di $\Sigma ^{*}$, o meglio L  $\subseteq \Sigma ^{*}$ 
Ad esempio:
\[\Sigma = {a, b, c} \to L_{1}={aa, cbc}  \subseteq \Sigma ^{*} \\
L_{2} = {w \in {a,b,c}^{*} t.c. ~ W ~ contiene ~ stesso ~ numero~di~a~e~c} \]
In pratica
\[L_{2} = {ac, ca, acb, abc, cab, cba, ...}\]
abc $\in L_{2}$?? Yes\\
ccbb $\in L_{2}$?? Nope\\
\paragraph{Detto meglio} (Problema di Membership) \\ $W \in \Sigma ^{*} \to L 
\begin{cases}
SI, ~ Se ~ w \in L \\
NO, ~ Se ~ W \in \Sigma ^{*} senza ~ L (Complemento~di~L)
\end{cases}$ \\ \\
Attenzione, il linguaggio è un insieme, contiene quindi ELEMENTI, e di 
conseguenza può contenere anche l'insieme vuoto! \\ \\
\paragraph{Osservazione:} w può essere appartente a $\Sigma ^{*}$ MA non 
all'insieme vuoto. Occhio a non confondersi
\\ \\
In generale un linguaggio formale va studiato secondo due punti di vista almeno.
\\ \\
Avendo un linguaggio L  $\subseteq \Sigma ^{*} posso 
\begin{cases}
generarlo ~(grammatica)\\
riconoscerlo ~(macchina~autonoma)
\end{cases}$
\paragraph{Grammatica} Insieme di regole che specificano come va fatta una stringa
Una grammatica G è una quadrupla $\to$ G = (V, T, P, S) ~in ~cui~
\begin{itemize}
	\item V: variabili
	\item T: Simboli terminali
	\item P: insieme delle produzioni
	\item $S \in V$: simbolo di start
\end{itemize}
\paragraph{I tipi di grammatiche}
Esiste una gerarchia (Noam) Chomsky, che negli anni 50 si poneva domande su 
cosa accade nel cervello umano quando si elabora un linguaggio. \\ \\
La sua ipotesi (smentita) c'è una sorta di grammatica codificata/cablata
per elaborare il linguaggio, e (malgrado smentita) è saltata comunque fuori 
questa gerarchia
\begin{enumerate}
	\item Grammatiche tipo 0: %, i 	
	\begin{itemize}
		\item Non hanno restrizioni sulle produzioni
		\item Sono riconosciuti dalle macchine di Turing (Alan Turing)
		\item linguaggi che generano sono i ricorsivamente numerati, li vedremo a 
		computabilità (Sia deterministiche che non)
	\end{itemize}
	\item Grammatiche Tipo 1: La testa ha lunghezza $\geq$ corpo, ne vedremo 
	solo due esempi
	\begin{itemize}
		\item Linguaggi dipendenti dal contesto, riconosciuti da macchine 
		particolari come la macchina di Turing, che lavorano spazio lineare
		Cioè Se n è la lunghezza della prima forma sentenziale da cui parto, 
		tutte le altre forme sentenziali non potranno essere più lunghe, e quindi
		non può crescere il numero di simboli, tenderà sempre a diminuire.
	\end{itemize}
	Le regole di produzione di tipo 1:
	$\alpha _{1} ~ A ~ \alpha _{2} ~ \to ~ \alpha _{1}~ \beta ~ \alpha_{2} ~ con ~ \alpha _{1,2}
	,\beta ~ \in ~ (V ~ \cup ~ T)^{*} ~ , ~ \beta ~ \neq ~ \epsilon, A\in V$
	\paragraph{Problema di decisione} E' un problema la cui risposta possibile è
	sì o no (Cioè alla fine true o false). Risolvere un problema di decisione non 
	pè altro che risolvere un problema di membership.
	\item Grammatiche Tipo 2: 
	Le regole di produzione qui sono del tipo A$\in$B, con A$\in$V e 
	$\beta \in(V \cup T)^{*}$
	Sono linguaggi context free, e vengono riconosciuti da macchine (o automi) a
	pila monoterministica
	\item Grammatiche Tipo 3: Sono le grammatiche regolari e quindi producono e
	generano semplicemente linguaggi regolari, e le produzioni delle grammatiche
	regolari si possono tutte trasformare in modo tale che A$\in$ aB $\wedge$ A
	$\in$ a con A, B$\in$V e a$\in$ T, riconosciuti da automi a stati finiti, 
	deterministici o monodeterministici
\end{enumerate}
Il complemento di un linguaggio può essere sia infinito che finito (Nel senso
posso escludere elementi oppure posso considerare solo quelli!)
\\ \\ 
\section{Linguaggio context-free (CFL) legati a grammatiche Context Free (CFG)}
In questo caso si utilizza una forma ricorsiva per definire questi linguaggi,
\\ \\
Ricordiamoci del fatto che io posso mettere due linguaggi in serie, posso 
includerne uno in un altro MA non posso accavallarli. Nel senso, o tutto di 
entrambi, o niente. Ma torniamo ai \textbf{Context free}
\\ \\
\paragraph{La stringa palindroma}
Sono stringhe la cui lettura è identica in qualsiasi verso si leggano. Supponiamo
$\Sigma$ = {0, 1} es. $L_{pal} \subseteq \Sigma ^{*} \to "0110", "11011", 
\epsilon$, perchè la stringa vuota è considerata palindroma. \\ 
Più in modo formale si può dore che w è \textbf{palindroma} quando $w = w^{R}$
Definizione induttiva:
\[
\begin{cases}
base:~\epsilon, 0, 1 \in L_{pal} \\
passo~induttivo:~ se ~w\in ~L_{pal} ~allora ~OwO, ~1w1 ~\in ~L_{pal}
\end{cases}
\]
\\
$
S \to \epsilon\\
S ~ \to ~ 0 \\
S ~ \to ~ 1 \\
S ~ \to ~ 0S0 \\
S ~ \to ~ 1S1$ \\
Con S che è una variabile (categoria sintattica), e \{0, 1\} che sono i simboli
terminali con cui si scrivono le stringhe del linguaggio.\\ \\
Queste si chiamano regole di produzione in cui la testa è occupata in questo
caso dalla freccia, mentre i vari 0 1 0S0 e 1S1 sono il corpo. S PUO' diventare
il corpo \\ \\ 
Detto questo possiamo dire che
$$G_{pal} = (V, T, P, S), ~in ~cui $$\\
\begin{itemize}
	\item V = \{S\}
	\item T = \{0, 1\}
	\item P = $S \in \epsilon, S \in 0, S \in 1, S \in 0S0, S \in 1S1$
\end{itemize}
Più in generale
$$G_{pal} = (\{S\},\{0, 1\}, P, S) ~  dove ~  P  ~ = ~  \{S \in \epsilon, ...\}$$
\paragraph{Derivazione}
$S \implies 1S1 \implies 10S01$, dove 1S1 è una forma sentenziale e la S cambia in
funzione delle regole che ho deciso sopra (per generare la stringa ovviamente.)
\\ \\ In modo compatto: \\
$S \in \epsilon | 0 | 1 | 0S0 | 1S1$
\\ \\
C'è una precisazione da fare, se per esempio avessi la regola che le mie stringhe
debbano iniziare per 0, quando andrò a fare 0S0, allora quell'S volendo può
essere sostituita con una \textbf{nuova} variabile che chiamiamo \textbf{X}. \\ \\
\textbf{X} non è altro che una variabile che rappresenta l'insieme di tutte le
palindrome.
Perchè cambiare variabile? Perchè se io voglio ad esempio le palindrome che 
iniziano per 0, devo avere, dato che non posso forzare l'ordine con cui vengono
applicate le mie regolo, devo avere un "permesso" speciale che consenta di 
generare 0 all'inizio alla fine. Cioè, dentro ci può essere un pandemonio, ma 
fuori ci deve essere la regola che stabilisce l'esistenza di 0.
\section{Parentesi bilanciate}
T =\{(,)\}, in cui () $\in$ $L_{pal}$, (()) $\in$ $L_{pal}$, ()() $\in$ $L_{pal}$,
$\epsilon \in L_{pal}$ \\ \\
Se W $\in L_{pal}$, allora (W) $\in L_{pal}$ esattamente come WW$\in L_{pal}$
\paragraph{Ex 5.19 p 182}
$\epsilon$ ()  ()() (w) $\L_{pal}$
$$\begin{cases}
\underline{base}: \epsilon	\\
\underline{Passo}: Se~w\in L_{pal} ~ allora ~ ww\in L_{pal} 
~AND~ (w)\in L_{pal} 
\end{cases}$$
Dato G=(V, T, P, B) \\
B $\to$ BB | (B) | $\epsilon$, \\ \\
V = \{B\} T = \{(, )\} e \\
P = \{B $\to$ BB, B $\to$ (B), B$\to \epsilon$\} \\ \\
A questo punto, se avessi ()(()) otterrei: \\
B $\implies _{1}$ BB $\implies _{2}$ B(B) $\implies _{2}$ (B)(B) $\implies _{3}$
()(B) $\implies _{2}$ ()((B)) $\implies _{3}$ ()(()) \\
Quindi questa stringa è possibile generarla.
\section{Produzioni Context - Free}
\paragraph{DISCLAIMER: } D'ora in poi vedrete qualcosa di questo genere: 
$\implies^{*}_{lm/rm}$,
dovete considerare tutte le volte in cui si presenteranno come se fossero 
$=>^{*}_{lm/rm}$, appena ho tempo poi li cambio tutti. cosa indicano rm lm e *
E' scritto tranquilli \\
\\
{\color{black} \rule{\linewidth}{0.3mm} }
\\
\\
A $\to$ $\gamma$ dove A $\in$ V e $\gamma \in (V\vee T)^{*}$ \\ \\
Agendo come prima:	\\
B $\implies _{1}$ BB $\implies _{2}$ (B)B $\implies _{3}$ ()B $\implies _{2}$ 
()(B) $\implies _{2}$ ()((B))$\implies _{3}$ ()(())
\section{Derivazione left/right most}
Per evidenziare che sia una letf o right most invece del numeretto, alla freccia
si aggiunge un lm o rm (Left o Right most). Sempre con l'esempio di prima -> \\ \\
B $\implies _{rm}$ BB $\implies _{rm}$ B(B) $\implies _{rm}$ B((B)) 
$\implies _{rm}$ B(()) $\implies _{rm}$ (B)(()) $\implies _{rm}$ ()(())
\paragraph{Ex 5.3, p 162}
Regole di produzione:
E $\in$ I | E + E | E * E | (E) \\ \\
I $\in$ a | b | Ia | Ib | I0 | I1 \\ \\
G = (V, T, P, E)      V = \{E, I\} \\
T = \{+, *, (, ), a, b, 0, 1\} \\ \\ \\
La E diventa identificatore quindi $E \implies I \implies a$ (stessa roba per b)
quindi $E \implies I \implies Ia \implies I0a \implies Ib0a \implies I1b0a 
\implies b1b0a$ 
\\ \\
%\implies I1b0a  \implies b1b0a \implies D10b01a$
\\ \\
Proviamo a generare a * (a+b00) (metodo Left-Most) \\
E $\implies _{lm}$ E * E $\implies _{lm}$ I * E $\implies _{lm}$ a * E
$\implies _{lm}$ A * (E) $\implies _{lm}$ a * (E + E) $\implies _{lm}$ a * 
(I + E) $\implies _{lm}$ a * (a + E) $\implies _{lm}$ a * (a + I) $\implies _{lm}$
a * (a + I0) $\implies _{lm}$ a * (a + I00) $\implies _{lm}$ a *(a + b00) \\ \\
Per parcondicio, ora faremo anche la generazione con il Right Most \\
E $\implies _{rm}$ E * E $\implies _{rm}$ E * (E) $\implies _{rm}$ E * (E + E)
$\implies _{rm}$ E (E + I) $\implies _{rm}$ E * (E + I0) $\implies _{rm}$ 
E * (E + I00) $\implies _{rm}$ E * (E + b00) $\implies _{rm}$ E * (I + b00)
$\implies _{rm}$ E * (a + b00) $\implies _{rm}$ I * (a + b00) $\implies _{rm}$ 
a * (a + b00) \\ \\
Per indicare che "in qualche modo" è possibile ottenere una determinata stringa
si scrive $$E \implies _{rm/lm}^{*}$$.
\\ \\ 
Data $\alpha A \beta, ~con~ \alpha \beta \in (V U T)^{*}, ~con~ A\in V$ \\
$A \in \gamma$ (Regole di produzione) \\
$\alpha A \beta \implies \alpha \gamma \beta$ 
\paragraph{Se A è var. più a sx} $\implies _{lm}$ altrimenti diventa 
$\implies _{rm}$ Nel caso sia più a destra
\\ \\
\section{Definizione di $\implies ^{*}$}
Per induzione: \\ \\
$$\begin{cases}
Base: ~\forall \alpha \in (V U T)^{*}, \alpha \implies ^{*} \alpha
Passo: ~Se~ \alpha \implies ^{*} \beta e \beta \implies \gamma \\
allora~ \alpha \implies ^{*} \gamma ~ dove ~ \alpha, \beta, \gamma 
\in (V U T)*
\end{cases}$$
Pertanto $\alpha \implies ^{*} \beta$ sse $\exists \gamma _{1}, \gamma _{2}, 
..., \gamma _{n} \in (VUT)^{*}$ con n$\geq$ t.c
$\alpha = \gamma _{1}, \beta = \gamma _{n} e \forall i = 1, 2, ..., n-1$ si ha che
$\gamma _{i} \implies \gamma _{i+1}$ 
\section{Definizione forma sentenziale}
Sia G = (V, T, P, S) una CFG, e $\alpha \in (VUT)^{*}$ t.c. S $\implies ^{*} \alpha$ \\ \\
Ogni volta che io genero nella forma sentenziale uno zero, in realtà se ne 
genera un altro, quindi se ho $S \implies 0S0 \implies 00S00$, imponendo un vincolo
sugli zeri prima e dopo la S, quindi per esempio se avessi: \\ \\
I $\to$ 0 | 1 | $\epsilon$ | I0 | I1 Reg. \\
$I \implies I0 \implies I00 \implies I000 \implies I1000 $
\section{Inferenza Ricorsiva}
L'obbiettivo è dimostrare che dato un obbiettivo si può ricavare in 0 o più passi
una determinata stringa. \\ (E' la stringa dell'esercizio precedente: )
Si agisce ponendo una tabella composta in questo modo 
\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
\hline
/ & Stringa ricavata & Variabile & N proof & Stringhe impiegate\\
\hline
(1) & a & I & 5 & - \\
(2) & b & I & 6 & -  \\
(3) & b0 & I & 9 & (2)\\
(4) & b00 & I & 9 & (3)\\
(5) & a & E & 1 & (1)\\
(6) & b00 & E & 1 & (6)\\
(7) & a+b00 & E & 2 & (5),(6)\\
(8) & (a+b00) & E & 4 & (7)\\
(9) & a*(a+b00) & E & 3 & (5),(8)\\
\hline
\end{tabular}
\end{center}
\section{Due teoremi importanti}
\subsection{Th. 1}
Sia G = (V, T, P, S) una CFG, e sia $\alpha \in (VUT)^{*} allora 
S \implies ^{*}\alpha ~sse~ \alpha ~ e' ~ ottenibile ~ tramite ~ procedura ~
\\ di  ~ inferenza ~ ricorsiva$
\subsection{Th. 2}
Sia G = (V, T, P, S) una CFG, e $\alpha \in (VUT)^{*} allora S \implies ^{*} \alpha$
se e solo se $S \implies_{rm}^{*} \alpha$ OPPURE $S \implies _{lm} ^{*} \alpha$
\section{Le Relazioni $\implies$}
Sia G = (V, T, P, S) una CFG e sia $\alpha A \beta$ t.c. $\alpha , \beta \in
(v\cup T)^{\star}$ e A $\in$ V. \\
Sia $A \to \gamma \in P$ allora $\alpha A \beta \implies \alpha \gamma \beta$
\section{Le Relazioni $\implies^{*}$}
$\alpha \implies^{*} \beta ,$ con $\alpha, \beta \in (V \cup T)^{*}$ se e solo se
$\exists \gamma_{1}, \gamma_{2}, ... , \gamma_{n} \in (V \cup T)^{*}$ t.c.
$\alpha = \gamma_{1} \implies \gamma_{2} \implies ... \implies \gamma_{n} = \beta$
Con $n \geq 1$
\chapter{Esercizi sulle CFG}
\paragraph{Esercizio 1: }Formare una CFG per il linguaggio \\
\[L = \{0^{n} 1^{n} | n \geq 1 \}\]
L = (01,0011,000111,00001111, $\to$)
\\ Proviamo a scrivere la grammatica: \\
G = (V, T, P, S), dove T = \{0, 1\} \\
$S \to 0S1 | 01$, ricordiamoci che non possiamo metterci $\epsilon$ perchè si è
specificatop che dobbiamo avere $n \geq 1$ (ricordandoci che n è il 
numero di 0 e 1), quindi 
\\ \\
Se $L = \{0^{n} 1^{n} | n \geq 1 \}$ \\
S $\to 0S1 | \epsilon$ \\
L = {$\epsilon$, 01, 0011, 000111, ...}
\paragraph{Esercizio 2: }Formare una CFG per il linguaggio \\
\[L = \{a^{n} | n \geq 1 \}\]
L = (aS,aaS,aaaS,aaaaS,aaaaa, ..., $\to$)
\\ Proviamo a scrivere la grammatica: \\
$S \to aS | a$, \href{https://www.youtube.com/watch?v=ATNolrWTYuU}
{ecco un esempio di applicazione di questo esercizio} 
\\ \\
Nel caso di questo esercizio è indifferente se la 'a' vien messa prima o dopo
la S
\paragraph{Esercizio 3: }Formare una CFG per il linguaggio \\
\[L = \{ (ab)^{n} | n \geq 1 \}\]
L = (ab, abab, ababab, abababab, ..., $\to$) (Rap Futuristico abababababab)
\\ Scriviamo la grammatica
$S \to abS | ab$ OPPURE, $S \to Sab | ab$
\\ \\
$S \implies Sab \vee abS \implies ... $ Non è sbagliato scriverli entrambi, ma
sarebbe auspicabile costruire due insiemi S in cui hai uno con la prima regola
ed uno in cui usi la seconda regola. Quindi si ha che: \\ \\
$S \implies Sab \implies Sabab ... $
$S \implies abS \implies  ababS ... $
Introduciamo le regole $A \to b$, $A \to bS$, $S \to aA$
\paragraph{Esercizio 4: }Formare una CFG per il linguaggio \\
\[L = \{ (a)^{n}cb^{n} | n \geq 1 \}\]
L = $\{S \implies aSb \implies aaSbb \implies aaaSbbb ...\}$
\\ Scriviamo la grammatica
$S \to aSb | acb$
\\ \\
Riassumendo: 
V = \{S\} \\
T = \{a,b,c\} \\
P = \{S $\to$ aSb, S $\to$ acb\}
\paragraph{Esercizio 5: }Formare una CFG per il linguaggio \\
\[L = \{ w\in \{a,b,c,d\}^{\star} | w = a^{n}, b^{n}, c^{\kappa}, d^{\kappa} \}
| ~ con ~  n, \kappa \geq 0 \}\]
L = $\{\epsilon, ab, aabb, aaabbb ... \\
cd, ccdd, cccddd ... \\
abcd, aabbcd, aaabbbcd, ... \\
abcd, abccdd, abcccddd, ...\}$ \\
Si ha che X = $\{a^{n}, b^{n}\} ~ e ~ Y=\{c^{\kappa}, d^{\kappa}\}$
\\ Scriviamo la grammatica
$S \to XY$\\
$X \to aXb | \epsilon $\\
$Y \to cYd | \epsilon $\\
Quindi alla fine abbiamo un linguaggio composto da due linguaggi, uno che è S, e 
poi rispettivamente X ed Y tali che: L = $L_{1}L_{2}$
\\
$L_{1} = \{ a^{n}b^{n} | n \geq 0 \}$
$L_{2} = \{ b^{\kappa}, b^{\kappa} | \kappa \geq 0 \}$
\\ \\
Per concatenare due linguaggi devo concatenare una qualsiasi stringa presa da 
un linguaggio, e una qualsiasi presa dal secondo.
Detto meglio:\\
Dati due linguaggi $L_{1} ed L_{2} \subseteq \Sigma^{\star}$, \\
$L_{1} \circ L_{2} = L_{1}L_{2} = \{ W | w = w_{1}w_{2}, con w_{1} \in L_{1}
e w_{2} \in L_{2}\}$, facciamo un esempio: \\ \\
\[
\Sigma^{\star} = \{0,1,a,b\}
L_{1} = \{ \epsilon, 0, 00, 011 \}
L_{2} = \{ ab, b \}
L_{1}L_{2} = \{ ab, b, 0ab, 0b, 00ab, 00b, 011ab, 011b\}
\]
\paragraph{Esercizio 6: }Formare una CFG per il linguaggio \\
\[L = \{ w\in \{a,b,c,d\}^{\star} | w = a^{n}, c^{\kappa}, d^{\kappa}, b^{n} 
| ~ con ~ n, \kappa \geq 0 \}\]
Si ha che X = $\{b^{\kappa}, b^{\kappa}\}$ e notiamo che l'esercizio è praticamente
come il precedente ma invece di concatenare andiamo ad inglobare uno dentro 
l'altro i linguaggi
\\ Scriviamo la grammatica
$S \to aSd | X$\\
$X \to bXc | \epsilon $\\
$Y \to cYd | \epsilon $\\
\\ \\
Vien fuori che: \\
$S \implies X \implies \epsilon$ \\
$S \implies aSd \implies aXd \implies abXcd \implies abcd$ \\
$S \implies X \implies bXc \implies bc$ \\
$S \implies aSd \implies aXd \implies ad$
\paragraph{Esercizio 7: }Formare una CFG per il linguaggio \\
$$L = \{ w\in \{a,b,c\}^{\star} | w = a^{n}, c^{\kappa}, n^{n}
| ~ con ~ n, \kappa \geq 0 \}$$
Consideriamo come negli esempi precedenti che $c^{\kappa} $sia una X (Ricordate 
X bestione? Quello del Dennunzio, ecco), per cui: \\
$S \to aSb | aXb$ \} \\
$X \to cX | c$ \} (Regolare)\\
\paragraph{Esercizio 8: }Formare una CFG per il linguaggio \\
\[L = \{ a^{n+m} x c^{m} y d^{m} n, m \geq 0 \}\]
In quest'ultimo caso è leggermente più complesso perchè dovremo dividere 
il nostro $a^{m+n}$ in due sotto casi.
\begin{itemize}
	\item $a^{n}a^{m}$ MA non va bene perchè se lo traduco vien fuori 
	\[a^{n}a^{m} x c^{n}yd^{m}\]
	E non va bene per via del fatto che c'è l'incrocio di m ed n
	\item $a^{m}a^{n}$ che è una soluzione accettabile perchè otteniamo:
	\[a^{m}a^{n} x c^{n}y d^{m}\] Se notate le n stanno dentro e le m stanno 
	fuori, sono diciamo racchiuse, pertanto è corretto +
\end{itemize}
\paragraph{Esercizio 9: }Formare una CFG per il linguaggio \\
$$L = \{ a^{n+m}xc^{n}yd^{m}, ~con~n,m \geq 0 \}$$
Come possiamo notare avremo $a^{n}a^{m}xc^{n}yd^{m}$ che non va bene, non si 
può fare. Ma possiamo anche considerarla come $a^{m}a^{n}xc^{n}yd^{m}$ \\ \\
$S \to aSd | By$ \\
$B \to aBc | x$ \\
$S \implies By \implies xy$
$S \implies aSd \implies aByd \implies aaBcyd \implies aaxcyd$
\paragraph{Precisazione: } Poichè sono stato assente per prendere gli appunti
della lezione successiva a questi esercizi ho lasciato nella cartella "Esercizi
preAlberi" tutto ciò che è stato fatto prima del prossimo argomento. \textbf{
Ringrazio di cuore Gaia per avere preso gli appunti di questa parte :)}
\chapter{Alberi Sintattici}
Un albero è una rappresentazione grafica che aiuta a comprendere in che modo una
certa forma sentenziale con simboli terminali o variabili è stata ottenuta con 
la derivazione
\paragraph{Definizione: }Dato G = (V, T, P, S), l'albero sintattico è t.c.
\begin{itemize}
	\item Ogni nodo interno è etichettato da una variabile
	\item Ogni foglia è etichettata da una variabile oppure un simbolo terminale,
	oppure anche $\epsilon$
\end{itemize}
Però se è etichettata con $\epsilon$ significa che è l'unico figlio del padre.
Inoltre, se un nodo interno è etichettato con A(variabile) e i figli sono
etichettati da Sx verso Dx con $x_{1}, x_{2}, ..., x_{\kappa}$ allora 
$A \to x_{1}, x_{2}, ..., x_{\kappa}$ e P.
\paragraph{Esempio CFG: } 
Dato $E \to I | E + E | E * E | (E)$ in cui la E sta per Espressione e la I
indica un identificatore. E \\
$I \to a | b | Ia | Ib | I0 | I1$ \\ \\ 
Forma Sentenziale I + E: \\
\[
\begin{tikzpicture}
\node (is-root) {E}
[sibling distance = 3cm]
child{ 
child{node{I}}
node{E}}
child{ node{+}}
child{ node{E}};
\end{tikzpicture}\]
Perciò se avessimo: $S \to aSb|\epsilon$ verrebbe fuori: \\
\begin{center}
\includegraphics[width=0.75\textwidth]{1}
\end{center}
La computazione di prolog non è altro che una visita di un albero in modo left
most, a seconda di come si visita l'albero infatti cambia ma il prodotto finale
rimane quello.
\\ \\
Dato un albero quindi non c'è un'unica derivazione.
\paragraph{Che rapporto c'è perciò tra alberi e derivazioni?}  
Data una CFG (Grammatica context free) G i seguenti enunciati si equivalgono:
\begin{enumerate}
	\item L'inferenza ricorsiva (quella della tabella in cui in base alla riga
	sapevam dire che valori poteva assumere partendo da quelli precedenti) 
	stabilisce che W (stringa) è nel linguaggio della variabile A
	\item Da A si può derivare in zero o più passi la stringa W
	\item Se esiste una derivazione sinistra di W in 0 o più passi, allora
	esisterà per forza anche una derivazione da destra per W
	\item Esisterà un albero sintattico con radice A e prodotto W
\end{enumerate}
Per esempio: 
\paragraph{fig 5.7 p 175}
\begin{center}
\includegraphics[width=0.75\textwidth]{derivazioneAlbero}
\end{center}
{\color{black} \rule{\linewidth}{0.3mm} }
\\
Nel caso dell'inferenza ricorsiva, si dimostra per induzione ($1 \to 5$) il numero
di passi (righe) dalla inferenza ricorsiva: 
$\begin{cases}
base: ~ A \to w \in P \\
passo~induttivo: ~ Inferenza ~ ricorsiva ~  di ~  n+1  ~ righe, ~  ultima \\ 
~ riga ~  A ~ \underbrace{\to w_{1}, w_{2}, ..., w_{\kappa}}_{w} \leq n ~righe
\end{cases}$
\\
{\color{black} \rule{\linewidth}{0.3mm} }
\begin{center}
\includegraphics[width=0.75\textwidth]{dimoAlberoInferenza}
\end{center}
{\color{black} \rule{\linewidth}{0.3mm} }
\[E \implies I \implies Ib \implies ab \\
\forall \alpha, \beta \in (V \cup T)^{*} ~vale~ che \\
\alpha E \beta \implies \alpha I \beta \implies \alpha I b \beta \implies
\alpha a ~ b \beta\]
Per induzione sull'altezza dell'albero: 
\begin{center}
\includegraphics[width=0.75\textwidth]{dimoAltezzaAlbero}
\end{center}
\section{Ambiguità}
E + E * E \\
$E \to E + E | E * E$
1) $E \implies E + E \implies E + E * E$ \\
2) $E \implies E * E \implies E + E * E$
\\
{\color{black} \rule{\linewidth}{0.3mm} }
\begin{center}
\includegraphics[width=0.75\textwidth]{iSeS}
\end{center}
{\color{black} \rule{\linewidth}{0.3mm} }
\\
\paragraph{Data la seguente CFG: } $S \to \epsilon|SS|iS|iSeS$ \\
Dobbiamo ottenere iie: \\
1) $S \implies iSeS \implies iiSeS \implies iieS \implies iie$ \\
2) $S \implies iS \implies iiSeS \implies iieS \implies iie$
\begin{center}
\includegraphics[width=0.75\textwidth]{iSeS}
\end{center}
Se per una stringa ci sono più di un albero sintattico allora essa è ambigua, 
invece non c'è problema se lo stesso albero dia più derivazioni è easy. Ma
perchè è un problema se è ambigua? Perchè non si sa come è cicciata fuori 
fondamentalmente.\\ \\
Non c'è un algoritmo che data una grammatica ti dica se è ambigua o non ambigua,
c'è pure una dimostrazione ma non la vediamo, è uno di quei problemi per cui
non si riesce a trovare una soluzione.\\ \\ Non è detto che una grammatica ambigua
sia trasformabile in una grammatica non ambigua PERO' in realtà in casi tipo 
Linguaggi di Programmazione (la materia dico) o negli XML ci son delle regole
che si sa che funzionino.\\ \\
Ci son linguaggi che sono inerentemente ambigui, ma ora vediamo anche degli esempi.
\paragraph{Riprendiamo gli identificatori: } I $\to$ a|b|Ia|Ib|I0|I1 \\
$F \to I | (E)$ \\
$T \to F | T * F$ \\
$E \to T | E + T$\\
\begin{center}
\includegraphics[width=0.75\textwidth]{iSeSB}
\end{center}
\paragraph{Teorema: } $\forall CFG$ \\
G = (V,T,P,S) e $\forall w\in T^{\star}$, w ha due alberi sintattici distinti se e
solo se ha due derivazioni sx distinte. \\
(Solo se): Supponendo due alberi distinti \\
(Se): Supponendo due alberi di derivazioni sx distinte\\ 
C'è un oppure, nel senso che questo è applicabile anche alle derivazioni da dx.
\paragraph{Si ma come fa un albero ad avere due derivazioni sx diverse?}
Esempio:\\
1) $E \to E + E \implies I + E \implies a + E \implies a + E * E \implies A + I * E
\implies a + a * E \implies a + a * I \implies a + a * a $\\
2) $E \implies E * E \implies E + E * E \implies I + E * e \implies a + E * E \implies A + I * E
\implies a + a * E \implies a + a * I \implies a + a * a $ \\ \\ 
Vediamo ora un esempio di linguaggio inerentemente ambiguo: \\
$\nexists$ CFG non ambigua, cioè: \\
L = $\{a^{n} b^{n} c^{m} d^{m} | n, m \geq 1\} \cup 
\{a^{n} b^{n} c^{m} d^{m} | n, m \geq 1\}$ \\
Definiamo le regole di inferenza: \\
\[\begin{cases}
S \to AB|C \\
A \to aAb|ab \\
B \to cBd|cd \\
C \to aCd|aDd \\
D \to bDc|bc 
\end{cases}\]
Ora vediamo come derivare la seguente stringa: "aabbccdd": (n = m - 2) TUTTO LEFT-MOST\\
1) $S \implies AB \implies aAbB \implies aabbB \implies aabbcBd \implies aabbccdd$ \\
2) $S \implies C \implies aCd \implies aaDdd \implies aabDcdd \implies aabbccdd$ \\
\\
Tutti i nodi vanno trasformati in questo, non si può trovare una grammatica 
fondamentalmente. Per non essere inerentemente ambiguo dovrebbe esserci una 
intersezione tra le due, e invece abbiamo ben due derivazioni sinistre diverse.
\\ \\
Per dimostrare davvero che sia inerentemente ambigue bisognerebbe fare una 
dimostrazione vera e propria ma diventa davvero complesso
\section{Grammatiche regolari}
Generano linguaggi di tipo 3 che si chiamano (Regolari) \\
G = (V, T, P, S): Analizziamo le Produzioni (P)\\ \\
Le produzioni hanno i seguenti vincoli:
\begin{enumerate}
	\item $\epsilon$ può comparire solo in $S \to \epsilon$ (S sta per start eh)
	\item Le produzioni sono tutte lineari a dx oppure tutte lineari a sx
	\item \begin{enumerate}
	\item lin a dx: $A \to aB$, oppure A$\to$a con A,B$\in$V e a$\in$T
	\item lin a sx: $A \to Ba$, oppure A$\to$a con A,B$\in$V e a$\in$T
\end{enumerate}
\end{enumerate}
Vediamo subito un esempio:\\
$I \to a|b|Ia|Ib|I0|I1$ lin sx\\
Si vuole rappresentare "b01" da destra verso sinistra\\
$I \implies I1 \implies I01 \implies b01$ \\
In pochi passaggi si è ottenuta subito la nostra stringa \\
Ora invece vediamo il lin dx\\
Ovvero si vuole rappresentare "b01" \\
$I \to a|b|aI|bI|0I|1I$ \\
$I \implies bI \implies b01 \implies b01I ... $ ? \\
Come vediamo non si risolve in questo caso, non esce la stringa, vediamo come fare.
\\ \\
Imponiamoci la regola che:
\[\begin{cases}
I \to aJ|bJ|a|b \\
J \to a|b|aJ|bJ|0J|1J|0|1
\end{cases}\]
Vediamo subito un esempio per capirci meglio: \\
G = (\{S\},\{0,1\},P,S) \\
lin dx: $S \to \epsilon|0|1|0S|1S$ \\
Da qui vediamo che dobbiamo escludere 0 ed 1 poichè
$L(G) = \{0,1\}^{\star}$\\ \\
Ora proviamo a produrre con lin sx 01101: \\
lin sx: $S \implies \epsilon | S0 | S1$
\paragraph{Esercizio} Si forniscano due grammatiche regolari lin dx ed sx per $L
= \{a^{n}b^{n}| n,m \geq 0\}$ \\
\begin{enumerate}
	\item lin dx: G=(\{S,B\}, \{a,b\},P,S)\\
	$S \to \epsilon | aS | bB$\\
	$B \to bB | b$, però così c'è un problema, nel senso che arriva alla B in cui
	può produrre soltando per l'appunto delle b, o comunque arriva che esce con b.
	\\  \\
	Come si risolve questo problema? Aggiungendo la b singola alla prima espressione 
	con S: $S \to \epsilon | aS | bB | \color{red} b \color{black}$
	\item lin sx: G=(\{S,B\}, \{a,b\},P,S)\\
	$S \to \epsilon | Sb | A0| a$ \\
	Con $A \to Aa | a$
\end{enumerate}
\paragraph{Esercizio: } Grammatica lin dx e sx per: \\
L = $\{ab^{n}cd^{m}e | n \geq 0, m \> 0 \}$ \\
\begin{enumerate}
	\item lin dx: \\
	$\begin{cases}
	S \to aA \\
	A \to bA|cB \\
	B \to dB | dE \\
	E \to e 
	\end{cases}$
	\item lin sx: \\
	$\begin{cases}
	S \to Xe\\
	X \to Xd | Yd\\
	Y \to Zc \\
	Z \to Zb | a 
	\end{cases}$
	\item lin dx: (modo equivalente)
	$A \to aB$\\
	$A \to w$\\
	$w\in T^{+}$ \\
	Per esempio: \\
	$A \to ciao \to \begin{cases}
	A \to cB \\
	B \to iC \\
	C \to aD \\
	D \to o
	\end{cases} $
	\item lin sx: \\
	$\begin{cases}
	A \to Bo \\
	B \to Ca \\
	C \to Di \\
	D \to c
	\end{cases}$
\end{enumerate}
\paragraph{Esercizio: } Data G = (\{S,T\},\{0,1\},P,S)\\
$\begin{cases}
S \to \epsilon | 0S | 1T\\
T \to 0T | 1S \\
\end{cases}$
L(G) =$\{w \in {0,1}^{\star} | ~ w ~ contiene~  un~  n ~ pari~  di~  1\}$
\paragraph{Altro esercizio: } Grammatica lin dx ed sx per:\\
L = -$\{w\in \{0,1\}^{\star}-$ | contiene almeno uno 0 oppure almeno un 1\}\\
L = $\{0,1\}^{+}$
\begin{enumerate}
	\item lin dx: G(\{S\},\{0,1\},P,S)\\
	$\begin{cases}
	S \to 0|1|0S|1S
	\end{cases}$
	\item lin sx: G(\{S\},\{0,1\},P,S)\\
	$\begin{cases}
	S \to 0|1|S0|S1
	\end{cases}$
\end{enumerate}
\chapter{Espressioni Regolari}
Esistono linguaggi regolari (Di tipo 3) che possono generare grammatiche regolari(
lin dx oppure lin sx) e rappresentare (\underline{dimostrare}) espressioni 
regolari.\\
Tramite espressioni regolari puoi dimostrare che una stringa fa parte di un 
linguaggio.\\
Inoltre puoi riconoscerle (\underline{accettare}) automi a stati finiti (DFA, 
NFA, $\epsilon$-NFA)
\section{Operazioni sui linguaggi}
\begin{enumerate}
	\item Unione: $L \cup M$ (Unione tra sistemi)\\
	Esempio:\\
	L = \{001,10,111\}
	M =$ \{\epsilon,001\}$
	$L \cup M$ = \{$\epsilon$, 10, 001, 111\}
	\item Concatenazione ($L\cdot M$)\\
	Esempio: \\
	L = \{001,10,111\}
	M = $\{\epsilon,001\}$
	$L \cdot M$ = \{$\epsilon$001, $\epsilon$10, $\epsilon$111, 001001, 10001, 111001\}	 
	\item Chiusura di Kleene: $L^{\star}$ \\
	L =$ \bigcup \limits _{i=1} L^{1} = \bigcup \limits _{i=1}^{\infty} L^{1}$\\
	Dove: $L^{0} = \{\epsilon\}, L^{1} = L$, fino ad arrivare a $L^{i}$ =
	$\underbrace{LLLLL...L}_{i~volte} $	i volte (per i $\geq$ 1)\\
	Esempio: \\
	L = \{0,11\} \\
	$L^{\star} = \{\epsilon\} \cup \{0,11\} \cup \{00,011,110,1111\} \cup 
	\{000,0011,01111,1100,11011,11110,111111\} \cup$ ...
\end{enumerate}
Ci sono dei casi particolari 
\begin{enumerate}
	\item $L = \varnothing $ (Non contiene stringhe)
	\item $L = \{\epsilon\} $(Cotiene solo la stringa vuota)
	\item $\varnothing = {\epsilon}$
	\item$ \varnothing^{i} = \varnothing ~~~ \forall i\geq1$
	\item $\varnothing^{\star} = \varnothing^{0}, \varnothing^{1}, ..., 
	\varnothing^{n}$
	\item $\{\epsilon\}^{\star} = \{\epsilon\}^{1}, \{\epsilon\}^{2}, ...,
	\{\epsilon\}^{n}$  = $\{\epsilon\}$
	\item Qualunque insieme se non vuoto, e non avente solo la stringa vuota,
	è in grado di generare qualsiasi stringa, di lunghezza che può estendersi
	fino ad $\infty$
\end{enumerate}
Tornando alle epsressioni regolari: \\
Si dice che esse denotino linguaggi regolari, dice come sono fatte le stringhe, 
in maniera più esplicita e compatta di una grammatica, e si definiscono 
in modo ricorsivo,(matematicamente per induzione, sempre lì si torna).\\ \\
Ci saranno dei casi base e una serie di passi, vediamo i 3 casi base:
\begin{enumerate}
	\item $\epsilon, \varnothing$ sono espressioni regolari, perciò $\epsilon$ ha 
	già più di un significato, di solito si indica in grassetto, per comodità
	in questo contesto sappiamo che indica un'espressione regolare (\textbf{$\epsilon$})\\
	L($\epsilon)$ = $\{\epsilon\}, L(\varnothing) = \varnothing$
	\item Se a $\in \Sigma$, a è una espressione regolare \\
	L(a) = \{a\}
	\item Variabili che rappresentano linguaggi: (L per esempio) sono espressioni
	regolari
\end{enumerate}
Vediamo ora i seguenti passi induttivi:
\begin{enumerate}
	\item Unione: Se E, F sono ER, allora E+F è una ER (E+F = L(E) $\cup$ L(F))
	\item Concatenazione: Se E, F sono ER, allora EF è una ER (L(EF) = L(E)L(F))
	\\ Ad esempio \\
	$\Sigma^{1} = \{0,1\}$, E = 0, F = 1 EF=01
	\item Chiusura: Se E è una ER, allora $E^{\star}$ è una ER $(E^{\star}=(L(E))^{\star})$
	\item Parentesi: Se E è una ER, allora (E) è una ER (  L((E))=L(E)  ) \\
	Vedrete lisp, a proposito di parentesi..
\end{enumerate}
\section{Precedenza operatori}
\begin{enumerate}
	\item Chiusura di Kleene ($\star$)
	\item Concatenazione A $\circ$ B
	\item Associativa, commutativa (l'unione) 
\end{enumerate}
\section{Esercizi}
\paragraph{Es. 1}
Data la seguente ER = $(0+1)^{\star} 0^{\star} (01)^{\star}$ \\
Dire se 001 è reaizzabile con il suddetto insieme: \\
$(0+1)^{\star}$ = 1 0 1 0\\
$L((0+1)^{\star}) = (L(0+1))^{\star} = (L(0)\cup L(1))^{\star} = (\{0\} \cup \{1\})
= (\{0,1\})^{*}$, quindi è possibile realizzarlo
\paragraph{Es. 2}
Data la seguente ER = $0^{\star} (01)^{\star}$ \\
Dire se 001 è reaizzabile con il suddetto insieme: \\
001 Si'
1001 NO \\
0101 Si' \\
\section{Identità ed annichilatori}
\subsection{L'identità} E' un valore tale per cui la somma con esso (identità +
valore) darà il valore stesso (a+x = x+a $\forall x \in$ ESISTENZA)\\
$\varnothing$ è un'identità per +: $\varnothing + E = E + \varnothing = E$ \\
$\epsilon$ è identità per$ \circ: \epsilon E = E\epsilon = E$ \\
\subsection{Annichilatore}
$\varnothing $è annichilatore per$ \circ: \varnothing E = E \varnothing = \varnothing$
\paragraph{Esercizio tipo esame}
Data ER = $((01)^{\star}10(0+1)^{\star})^{\star}$
E' possibile realizzare 0101? Nope\\
01000? Nemmeno \\
01011 Nemmeno \\
10111 SI PUO' FARE WOOOOO (Perdonatemi, lo svolgimento lo aggiungerò successivamente
quando ci studierò sopra, perchè al momento mi è troppo lungo scriverlo)
\section{Distributività}
Aritmeticamente se ho $x(y+z)$, posso riscriverlo come $xy+xz$.
Consideriamo due tipi di distributività:
\begin{itemize}
	\item Distributività SX della concatenazione rispetto all'unione: \\
	$L(M+N) = LM + LN$
	\item Distributività DX: $(M+N)L = ML + NL$
\end{itemize}
\paragraph{Vediamo subito un esempio: } Data una ER `$0+01^{\star}$`
\[
L(0+01^{\star}) = L(0) + L(01^{\star}) = \{0\} \cup L(0)L(1^{\star}) =
\]
\[
= \{0\} \cup \{0\} (L(1))^{\star}) = \{0\} \cup \{0\} \{1\}^{\star} = 
\]
\[
\{0,01,011,0111, 01111, ...\}
\]
Con:
\[
\begin{cases}
\{1\}^{\star} = \epsilon, 1, 11, 111, 1111, ... \\
\{0\} \{1\}^{\star} = \epsilon, 01, 011, 0111, 01111, ...
\end{cases}
\]
A questo punto passiamo a considerare `$0+01^{\star}$`:
\[
0+01^{\star} = 0\epsilon + 01^{\star} = 0(\epsilon + 1^{\star}) = 01^{\star}
\]
\[
= (0(\epsilon + 1^{*})) = L(0) L(\epsilon + 1^{*}) = 
\]
\[
= \{0\} (\{\epsilon\} \cup L(1))^{*}) ...
\]
\section{Idempotenza}
Dal punto di vista dell'unione si ha che L + L = L, ma se visto aritmeticamente
viene leggermente più chiaro da capire, infatti:
\[x+x\neq x\]
La somma non gode dell'indepotenza
\[x\cdot x\neq x\]
Ed allo stesso modo non ne gode nemmeno il prodotto
\section{Proprietà chiusura}
\[
(L^{\star})^{\star} = L^{\star}
\]
\[
(L^{\star})^{\star} = \bigcup \limits _{i \geq 0} {(L^{\star})^{i}}
\]
Da questo si deriva che $\varnothing^{\star}=\epsilon$ e $\epsilon^{\star}=\epsilon$,
ora passiamo ad $L^{+}$
\[
L^{+} = LL^{*} = L^{*}L = L + LL + LLL + LLL = L\epsilon + LL * LLL =
\]	
\[
L(\epsilon + L + LL + LLL * ....) = LL^{*}
\]	
\paragraph{Esercizio 1: } Data ER = $(00^{*}1^{*})^{*}$\\ 
Fin da subito osserviamo che avremo una serie di blocchi tutti inizianti per
0 di questo tipo: $0xxxx0xxxx0xxxx$, potrebbero capitare blocchi aventi una
serie di 0 ed una serie di 1. 
\begin{itemize}
	\item Posso avere una stringa tutta di 1? No
	\item Una stringa avente uno 0 e tutti 1? Sì
\end{itemize}
Non l'ho specificato ma $\epsilon \in L$ \\
Quello che si nota è che quindi ogni stringa che avrò inizia per 0, perciò potrò
scrivere qualcosa del tipo $0(0+1)^{*} + \epsilon$
\paragraph{Esercizio 2: } Quale linguaggio si denota da questa ER: $a(a+b)^{*}b$?\\
L = $\{w \in \{a,b\}^{*} |$ w inizia con a e termina con b\}, spiegato peggio 
sarebbero tutte le strinche che iniziano con a e b, ed all'interno hanno 
qualsiasi combinazione
\paragraph{Esercizio 3: } Quale linguaggio si denota da questa ER: $(0^{*}1^{*})000(0+1)^{*}$?\\
E' in pratica come dire, qualsiasi insieme di 0 ed 1 (zeri ed uni) che in mezzo
da qualche parte avranno un punto in cui ci sarà una sequenza di 3 zeri
\paragraph{Esercizio 4: } Quale linguaggio si denota da questa ER: $a(a+b)^{*}c(a+b)^{*}c(a+b)^{*}b$?\\
L = \{$w\in \{a,b,c\}$ | w inizia con a, termina con b, e contiene esattamente DUE c\}
\paragraph{Esercizio 5: } Scrivere un'ER per questo linguaggio: 
L = $\{w\in \{0,1\}\}$ | in w, tutte le coppie 11 seguono tutte le coppie 00, 
nel senso:
\[
L = L_{11}L_{00} 
\]
Attenzione, tutte le coppie 11 SEGUONO tutte le coppie 00, quindi da un lato
si hanno tutti gli 00 e dall'altra 11: 0011, 00001111, 0000000011111111 
\subparagraph{Proviamo a scrivere le ER } 
\begin{itemize}
	\item Per $L_{11}$: $(10+0)^{*}(\epsilon + 1)$
	\item Per $L_{00}$: $(01+0)^{*}(\epsilon + 0)$
\end{itemize}
Ed infine proviamo a scrivere l'ER per L:
\[
(10+0)^{*} (\epsilon + 1) (01+1)^{*} (\epsilon + 0)
\]
Si può addirittura elidere $(\epsilon + 1)$ poichè comparirebbe nella parentesi
dopo.
\chapter{Automi a stati finiti deterministici (DFA)}
Sono insiemi di stati legati da una serie di archi di transizione, e sono 
strettamente legati ai linguaggi regolari, perchè sono generati da grammatiche 
regolari, cioè di tipo 3, ed accettati da DFA. \\ \\
O meglio, le stringhe generate dalla grammatica regolare posso darli in pasto
al mio automa in grado di leggere la stringa carattere per carattere, e 
quest'ultimo sarà in grado di dirmi se codesta stringa è generabile. \\ \\
Inoltre sono denotati da espressioni regolari
\section{Come sono fatti}
Ecco un esempio di DFA
\begin{center}
\includegraphics[width=0.75\textwidth]{dfa}
\end{center}
Però bisogna anche adesso includere alcune cose: 
Ogni automa ha una casellina in cui si può inserire un carattere, pertanto avremo
un alfabeto $\Sigma$.\\ \\
Perciò si ha un insieme di stati (\textbf{Q}), un sotto insieme di \textbf{Q} che
son stati finali $F\subseteq Q$ \\
Dato un linguaggio regolare si ha un automa che entra in stato finale SE esaminata
carattere per carattere la stringa si arriva fino alla fine.
\\
{\color{black} \rule{\linewidth}{0.3mm}}
\paragraph{Rappresentazione di Gaia più accurata}
\begin{center}
\includegraphics[width=0.75\textwidth]{rappreDFA}
\end{center}
{\color{black} \rule{\linewidth}{0.3mm}}
\\
\paragraph{Osservazione: } Una volta letto un simbolo, viene consumato, essa
sparisce, non viene più ripresa. In aula è stato fatto l'esempio di un mitra, che
spara i colpi uno dopo l'altro ed una volta sparato non c'è modo di recuperare
un colpo.
\section{Definizione formale}
E' una quintupla in cui:
\begin{itemize}
	\item Q è l'insieme finito degli stati
	\item $\Sigma$ è l'alfabeto delle stringhe date in input
	\item $\delta$ è la funzione di transizione degli stati
	\item $q_{0}\in Q$ è lo stato iniziale
	\item $F \subseteq Q$ è l'insieme degli stati finali
\end{itemize}
In pratica $\delta:Qx\Sigma \to Q$ che riassunto vuoldire, prendo uno stato, 
una lettera dell'alfabeto, e rimango nello stato. E $\delta(q,a) = p$
\paragraph{Esercizio 1: } Generare un DFA che accetti w$\in \{0,1\}^{*}$ | w
contiene un numero pari di 1 \\ \\
A = $(\{q_{p}, q_{d}\}, \{0,1\}, \delta, q_{p}, \{q_{p}\}) $(La p sta per pari,
la d per dispari)
\begin{itemize}
	\item $\delta(q_{p}, 0) = q_{p}$
	\item $\delta(q_{d}, 0) = q_{d}$
	\item $\delta(q_{p}, 1) = q_{p}$
	\item $\delta(q_{d}, 1) = q_{d}$
\end{itemize}
A questo punto è necessario fare la nostra tabella 2 x 2 
\begin{center}
\begin{tabular}{ | c | c | c }
/ &  0 & 1 \\ 
$q_{p}$ & $q_{p}$  &  $q_{d}$ \\  
$q_{d}$ &  $q_{d}$ & $q_{p}$     
\end{tabular}
\end{center}
Il disegno dell'automa non l'ho fatto io, ringrazio Gaia (ormai son più suoi
che miei questi magici appunti)
\begin{center}
\includegraphics[width=0.75\textwidth]{2}
\end{center}
\paragraph{Esercizio 2: } Definire una ER per L = \{w$\in \{0,1\}^{*}$ | w
contiene un numero pari di 1\} \\ \\
In pratica prima abbiamo generato l'automa, a questo punto proviamo a definire
una ER $\to (0^{*},1,0^{*},1)^{*}0^{*}$
\paragraph{Esercizio 3: } Progettare un DFA che accetti 
L=$\{x01y|x, y\in\{0,1\}^{\star}\}$. Per prima cosa bisogna ragionare su quali
sono le più corte stringhe che il linguaggio accetti, e si verifica che la
stringa più corta sia $01 \in L$\\ \\
Consideriamo che uno stato iniziale si indica con una freccia esterna che si 
chiami start, e lo stato finale invece sia un cerchio dentro l'altro.
Il nostro automa risulterà: A = $(\{q_{0}, q_{1}, q_{2}\},\{0, 1\},\delta,q_{0},\{q_{1}\})$\\
(I successivi automi sono stati fatti da \href{https://github.com/LiaBell47}{Giulia})
\begin{center}
\includegraphics[width=0.75\textwidth]{3}
\end{center}
in cui $\delta(q_{0},0)=q_{2}$
\paragraph{Esercizio 3:} Stabilire ER per L = $\{w \in \{0, 1\}^{\star}\}$ | w
contiene un numero di 0 divisibile per 3\}
\subparagraph{Soluzione: } ER = $(1^{*}01^{*}01^{*}0)^{*}1^{*}$
\paragraph{Osservazione: } Un DFA non è in grado di rappresentare delle CFG, e 
questo perchè un automa a stati finiti ha della memoria finita. Per questa 
ragione, non può appunto rappresentare delle Context Free
\paragraph{Esercizio 4: } Progettare un DFA per L = $\{w\in\{0,1\}^{\star} | w = 0^{n}1^{n}\}$ con:
\begin{itemize}
	\item n,m $\geq$ 0
	\begin{center}
	\includegraphics[width=0.75\textwidth]{4}
	\end{center}
	A = $(\{q_{0}, q_{1}, q_{E}\},\{0, 1\},\delta,q_{0},\{q_{1}\})$
	\item n$\geq 0, m>0$
	\begin{center}
	\includegraphics[width=0.75\textwidth]{5}
	\end{center}
	\item n > 0, m$\geq$ 0, $\epsilon \notin L, 0 \in L$
	\begin{center}
	\includegraphics[width=0.75\textwidth]{6}
	\end{center}
	\item n > 0, m > 0
	\begin{center}
	\includegraphics[width=0.75\textwidth]{7}
	\end{center}
\end{itemize}
($q_{E}$ sarebbe lo stato di errore)
\paragraph{Esercizio 5: }Progettare un DFA per L = $\{w\in \{a,b\}^{\star}$|\}
w contiene un numero pari di a ed un numero dispari di b\}
\begin{center}
\includegraphics[width=0.75\textwidth]{8}
\end{center}
Come si può osservare è un automa molto regolare, perchè in qualche modo
si prende l'automa che riconosce le a pari, uno che riconosce le b dispari e 
si sono accostati i due tra di loro (Ok, è informale, esiste l'automa prodotto,
Ma lo vedremo in seguito)
\paragraph{Esercizio 6: } Progettare un DFA per L = $\{w\in \{a,b\}^{\star}\}$|
w contiene un numero pari di a \textbf{seguito} da un numero
dispari di b $\implies \{a^{2n}b^{2k+1}\} | n, k \geq 0\}$
\begin{center}
\includegraphics[width=0.75\textwidth]{9}
\end{center}
\section{Estensione di $\delta$}
Finora si è detto che $\delta:Q \times \Sigma \to Q$ e $\delta(q,a) = p$ 
L'estensione $\widehat{\delta}:Q \times \Sigma^{\star}\to Q$ \\ \\
Se $w\in \Sigma^{\star}, \widehat{\delta}(q,w) = p$\\ \\
\paragraph{Torniamo all'esercizio 6} In questo caso quindi, si scriverà:
\begin{center}
\includegraphics[width=0.75\textwidth]{10}
\end{center}
\paragraph{Esercizio 7: }
\begin{center}
\includegraphics[width=0.75\textwidth]{11}
\end{center}
\paragraph{Esercizio 8: }
\begin{center}
\includegraphics[width=0.75\textwidth]{12}
\end{center}
\paragraph{Esercizio 8: }Produrre una ER per L =$ \{w\in \{0,1\}^{\star} $| 
contiene al più (al massimo) una coppia di 1 consecutivi\}
\[
(10+0)^{*}(11+1+\epsilon)(01+0)^{*}
\]
Il primo blocco non può essere ($1+0^{*}$) perchè altrimenti verrebbero fuori in 
mezzo anche coppie di 11.
\paragraph{Esercizio 9: }
Produrre una ER per L = $\{w \in \{a,b,c\}^{*}$ | w contiene almeno una a e almeno
una b\}
\[
c^{*}(a(a+c)^{*}b+b(b+c)^{*}a)(a+b+c)^{*}
\]
\paragraph{Esercizio 10: }
Progettare un DFA per L = $\{w \in \{0,1\}^{*} | w = x010y, ~con~x,y\in\{0,1\}^{*}\}$ 
\begin{center}
\includegraphics[width=0.75\textwidth]{13}
\end{center}
\paragraph{Esercizio 11:}
Progettare un DFA per L = $\{w \in \{0,1\}^{*}$ | le coppie 00 precedono le 
coppie 11\}
\begin{center}
\includegraphics[width=0.75\textwidth]{14}
\end{center}
\paragraph{Esercizio 12:}

Dato il seguente DFA:
\begin{center}
\includegraphics[width=0.75\textwidth]{15}
\end{center}
Consideriamo la stringa w = 0011 $\in$ L
$\widehat{\delta}(q_{0}, 0011$ = $\widehat{\delta}(\delta(q_{0},011))$ =
$\widehat{\delta}(q_{2},011)$ = $\widehat{\delta}(\delta(q_{2},0).11)$ = 
$\widehat{\delta}(q_{2},11)$ = $\widehat{\delta}(\delta(q_{2},q)$ = 
$\widehat{\delta}(q_{1},1)$ = $\widehat{\delta}(\delta(q_{1},1),\epsilon)$ = 
$\widehat{\delta}(q_{1}, \epsilon) = q_{1}\in F \to w = 0011 \in L$
\paragraph{Il libro usa questo metodo: }
$\widehat{\delta}(q,xa)$ = $\delta(\widehat{\delta}(q,x),a)$ 
con xa$\in \Sigma^{*} e a \in \Sigma$
\\ \\ 
Devo capire se 0011 appartiene al linguaggio, quindi: \\ \\
$\widehat{\delta}(q_{0},0011) = \delta(\widehat{\delta}(q_{0},001),1)$ =
$\delta(\delta(\widehat{\delta}(q_{0},00),1),1$ =  
$\delta(\delta(\delta(\delta(\widehat{\delta}(q_{0},00),1),1),1),1)$ con \\ \\
$\delta(\widehat{\delta}, \epsilon) = q_{0}$ e \\ \\
$\delta(\widehat{\delta},0) = \delta(\widehat{\delta}(q_{0},\epsilon),0)$ =
$\delta(q_{0},0 = q_{2}$ =\\ \\
$\delta(\widehat{\delta},00) = \delta(\widehat{\delta}(q_{0},0),0)$ =
$\delta(q_{0},0 = q_{2}$ = \\ \\
$\delta(\widehat{\delta},001) = \delta(\widehat{\delta}(q_{0},00),1)$ =
$\delta(q_{2},3 = q_{1}$ = \\ \\
$\delta(\widehat{\delta},0011) = \delta(\widehat{\delta}(q_{0},001),1)$ =
$\delta(q_{1},1 = q_{1}$
\paragraph{Esercizio 13: }
Progettare un DFA per L = $\{w \in \{0,1\}^{*}$ | w contiene almeno una volta
000\}
\begin{center}
\includegraphics[width=0.75\textwidth]{16}
\end{center}
\paragraph{Esercizio 14: }
Progettare un DFA per L = $\{w \in \{0,1\}^{*}$ | w \textbf{non} contiene
000\}
\begin{center}
\includegraphics[width=0.75\textwidth]{17}
\end{center}
Dato un linguaggio ed un automa per esso, per capire come fare il complemento (
tutte le stringhe che NON appartengono al linguaggio) osserviamo il modo in cui
differiscono i due esercizi precedenti 
\paragraph{Esercizio 15: }
Progettare un DFA per L = $\{w \in \{0,1\}^{*}$ | w contiene esattamente una volta
000\}
\begin{center}
\includegraphics[width=0.75\textwidth]{18}
\end{center}
\paragraph{Esercizio 16: }
Progettare un DFA per L =$ \{w \in \{a,b,c\}^{*}$ | w finisce con b e le occorrenze
di b sono singole o a coppie\}
\begin{center}
\includegraphics[width=0.75\textwidth]{19}
\end{center}
\section{Automa a stati finiti NON deterministico: NFA}
Per introdurci a questo argomento, vediamo un esercizio:
\paragraph{Esercizio 17: }
Progettare un DFA per L = \{x01 | x$\in\{0,1\}^{*}$\}
\begin{center}
\includegraphics[width=0.75\textwidth]{20}
\end{center}
In caso di automi complicati potrebbero verificarsi sviste, problemi o errori, 
pertanto sono stati inventati gli automi a stati finiti \textbf{NON} deterministici.
\\ \\
Nei DFA $\delta$ prende lo stato in cui si trova l'automa, prende l'input e dice
cosa diventerà quello stato MENTRE nell'NFA $\delta$ guarda cosa entra e poi 
ci indirizza ad un certo insieme di stati:
\[
\delta : Q \times \Sigma \to 2^{Q}
\]
\begin{center}
\includegraphics[width=0.75\textwidth]{21}
\end{center}
Come è possibile notare adesso $\delta$ è diventata una funzione parziale, inoltre
il non determinismo è visibile in due modi:
\begin{enumerate}
	\item Trovo tutte le possibilità, cioè l'automa si trova in più stati 
	contemporaneamenta, si spezza, si duplica, ed una parte continua con una
	sua computazione, l'altra con la sua. 
	\begin{center}
	\includegraphics[width=0.75\textwidth]{22}
	\end{center}
	\paragraph{Cosa notiamo? }Uno dei rami farà morire la coputazione, nel senso
	che letteralmente si blocca, non può proseguire, ma gli altri possono continuare.
\end{enumerate}
{\color{black} \rule{\linewidth}{0.3mm}}
\paragraph{Esercizio: }Dato L =\{$x01|x\in\{0,1\}^{\star}$\} 
Il DFA risulterebbe: 
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (13.5,-21.5) circle (3);
\draw (13.5,-21.5) node {$q0$};
\draw [black] (37.2,-20.2) circle (3);
\draw (37.2,-20.2) node {$q1$};
\draw [black] (55.5,-19.2) circle (3);
\draw (55.5,-19.2) node {$q2$};
\draw [black] (55.5,-19.2) circle (2.4);
\draw [black] (6.7,-25.8) -- (10.96,-23.1);
\draw (6.07,-27.1) node [left] {$start$};
\fill [black] (10.96,-23.1) -- (10.02,-23.11) -- (10.56,-23.95);
\draw [black] (16.455,-20.98) arc (98.98993:87.28939:87.21);
\fill [black] (34.21,-20.01) -- (33.43,-19.47) -- (33.38,-20.47);
\draw (25.24,-19.49) node [above] {$0$};
\draw [black] (52.843,-20.586) arc (-66.99585:-106.74854:18.926);
\fill [black] (52.84,-20.59) -- (51.91,-20.44) -- (52.3,-21.36);
\draw (46.54,-22.61) node [below] {$1$};
\draw [black] (14.823,-24.18) arc (54:-234:2.25);
\draw (13.5,-28.75) node [below] {$1$};
\fill [black] (12.18,-24.18) -- (11.3,-24.53) -- (12.11,-25.12);
\draw [black] (39.854,-18.807) arc (113.12545:73.13016:18.826);
\fill [black] (39.85,-18.81) -- (40.79,-18.95) -- (40.39,-18.03);
\draw (46.16,-16.77) node [above] {$0$};
\draw [black] (37.971,-23.087) arc (42.69007:-245.30993:2.25);
\draw (35.32,-27.41) node [below] {$0$};
\fill [black] (35.38,-22.57) -- (34.45,-22.74) -- (35.13,-23.48);
\draw [black] (54.072,-21.836) arc (-32.05375:-141.67726:23.813);
\fill [black] (15.21,-23.96) -- (15.31,-24.9) -- (16.1,-24.28);
\draw (35.25,-33.53) node [below] {$1$};
\end{tikzpicture}
\end{center}
Mentre l'NFA: $S:Q\times\Sigma \to 2^{Q}$ con $Q = \{a,b,c\}$ e
$2^{Q} = \{\varnothing, \{a\}, \{b\}, \{c\}, \{a,b\}, \{a,c\, \{b,c\},\{a,b,c\}\}$
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (16.8,-20.8) circle (3);
\draw (16.8,-20.8) node {$q0$};
\draw [black] (40.1,-20.9) circle (3);
\draw (40.1,-20.9) node {$q1$};
\draw [black] (64.6,-20.2) circle (3);
\draw (64.6,-20.2) node {$q2$};
\draw [black] (64.6,-20.2) circle (2.4);
\draw [black] (19.8,-20.81) -- (37.1,-20.89);
\fill [black] (37.1,-20.89) -- (36.3,-20.38) -- (36.3,-21.38);
\draw (28.45,-20.35) node [above] {$0$};
\draw [black] (43.045,-20.329) arc (99.68657:83.58658:66.376);
\fill [black] (61.63,-19.8) -- (60.89,-19.21) -- (60.78,-20.21);
\draw (52.3,-18.88) node [above] {$1$};
\draw [black] (8.1,-20.8) -- (13.8,-20.8);
\draw (7.6,-20.8) node [left] {$start$};
\fill [black] (13.8,-20.8) -- (13,-20.3) -- (13,-21.3);
\draw [black] (17.807,-23.614) arc (47.41806:-240.58194:2.25);
\draw (15.6,-28.16) node [below] {$0,1$};
\fill [black] (15.18,-23.31) -- (14.27,-23.56) -- (15.01,-24.24);
\end{tikzpicture}
\end{center}
Ora disegnamo la tabella:
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
& 0 & 1 \\ \hline
q0 & \{q0,q1\} & \{q0\} \\ 
\hline
q1 & $\varnothing$ & \{q2\} \\
\hline
q2 & $\varnothing$ & $\varnothing$ \\ 
\hline
\end{tabular}
(Siccome non so come fare questo grafico, ringrazio di nuovo l'esistenza di Gaia)

\includegraphics[width=0.75\textwidth]{23}
\end{center}
A questo punto come si sviluppa $\widehat{\delta}(q,w)?$ Che ci dice in quale 
stato si trova l'automa dopo aver consumato w. O meglio, in quale insieme di stati
si va a trovare.
\paragraph{$1^{a}$ definizione induttiva: }
\begin{center}
	\begin{itemize}
		\item Base: $\widehat{\delta}(q,w) = \{q\} \forall q \in Q$
		\item Passo induttivo: posto $w = ax$, con $a \in \Sigma$ e $x \in 
		\Sigma^{\star}$ e $\delta(q,a) = \{p_{1}, p_{2}, ..., p_{x}\}$ ALLORA
		$\widehat{\delta} = \bigcup \limits_{i=1}^{k} \widehat{\delta}(p_{i},x) =
		\{r_{1}, r_{2}, ..., r_{m}\}$
	\end{itemize}
\end{center}

\paragraph{$2^{a}$ definizione induttiva: }
\begin{center}
	\begin{itemize}
		\item Base: $\widehat{\delta}(q,w) = \{q\} \forall q \in Q$
		\item Passo induttivo: posto $w = xa$, con $a \in \Sigma$ e $x \in 
		\Sigma^{\star}$ e $\delta(q,x) = \{p_{1}, p_{2}, ..., p_{x}\}$ ALLORA
		$\widehat{\delta} = \bigcup \limits_{i=1}^{k} \widehat{\delta}(p_{i},a) =
		\{r_{1}, r_{2}, ..., r_{m}\}$
	\end{itemize}
\end{center}
(Per farla in breve, è identica MA si invertono la x e la a.)
\paragraph{Esempio: }Data la stringa w = 00101, \\
$\widehat{\delta}(q_{0}, \epsilon) = \{q_{0}\}$, \\
$\widehat{\delta}(q_{0}, 0) = \delta(q_{0},0) = \{q_{0}, q_{1}\}$, \\
$\widehat{\delta}(q_{0}, 00) = \delta(q_{0},0) \cup \delta(q_{1},0) = 
\{q_{0},q_{1}\cup \varnothing\} = \{q_{0},q_{1}\}$\\
$\widehat{\delta}(q_{0}, 001) = \delta(q_{0},1) \cup \delta(q_{1},1) = 
\{q_{0}\} \cup \{q_{2}\} = \{q_{0}, q_{2}\}$ \\
$\widehat{\delta}(q_{0}, 0010) = \delta(q_{0},0) \cup \delta(q_{2},0) =
\{q_{0},q_{1}\}\cup \varnothing = \{q_{0},q_{1}\}$ \\
$\widehat{\delta}(q_{0}, 00101) = \delta(q_{0}, 1) \cup \delta(q_{1},1) =
\{q_{0}\}\cup \{q_{2}\} = \{q_{0}, q_{2}\}$ \\
Dato che $q_{2}$ è stato accettante, ovvero appartiene all'insieme degli stati finali
la stringa w = 00101 è accettata dall'automa (NFA)
\section{Linguaggio accettato}
\paragraph{Definizione: }Sia A = (Q, $\Sigma, \delta, q_{0}$, F) un NFA, il 
linguaggio accettato da A è 
\[
	L(A)=\{w\in \Sigma^{\star} | \widehat{\delta}(q_{0},w \cap F \neq \varnothing\}
\]
\section{Trasformazione da NFA a DFA}
Per ogni NFA esiste un DFA in grado di simularlo:
\paragraph{Definizione: }Dato un NFA N = ($Q_{N}, \Sigma, \delta_{N},q_{0}, F_{N}$)
costruiamo un DFA D = ($Q_{D},\Sigma, \delta_{D},\{q_{0}\}, F_{D}$)
Però occhio, la presenza di $q_{0}$ dovrebbe violare la definizione di DFA, 
pertanto possiamo pure chiamarlo Pippo, possiamo rinominarlo come ci pare. 
Questo insieme che vediamo come $q_{0}$, il DFA lo vede come entità/oggetto 
indivisibile TALE CHE L(D) = L(N) (costruzione per sottoinsiemi) %lolololol <3
\subparagraph{Com'è fatto $Q_{D}$?} E' l'insieme della parti di $Q_{N}$, ossia $2^{Q_{N}}$
\subparagraph{Com'è fatto $F_{D}$?} $F_{D}$ = \{$S \subseteq Q_{N}|S\cap F_{n}\neq 
\varnothing$\}	
\subparagraph{Com'è fatta $\delta_{D}$?} $\forall S \subseteq Q_{N}$ e $\forall a \in \Sigma$
$\delta_{D}(S,a) = \bigcup \limits_{p \in S} \delta_{N}(p,a)$	
\paragraph{Riprendiamo l'automa di prima: }
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (16.8,-20.8) circle (3);
\draw (16.8,-20.8) node {$q0$};
\draw [black] (40.1,-20.9) circle (3);
\draw (40.1,-20.9) node {$q1$};
\draw [black] (64.6,-20.2) circle (3);
\draw (64.6,-20.2) node {$q2$};
\draw [black] (64.6,-20.2) circle (2.4);
\draw [black] (19.8,-20.81) -- (37.1,-20.89);
\fill [black] (37.1,-20.89) -- (36.3,-20.38) -- (36.3,-21.38);
\draw (28.45,-20.35) node [above] {$0$};
\draw [black] (43.045,-20.329) arc (99.68657:83.58658:66.376);
\fill [black] (61.63,-19.8) -- (60.89,-19.21) -- (60.78,-20.21);
\draw (52.3,-18.88) node [above] {$1$};
\draw [black] (8.1,-20.8) -- (13.8,-20.8);
\draw (7.6,-20.8) node [left] {$start$};
\fill [black] (13.8,-20.8) -- (13,-20.3) -- (13,-21.3);
\draw [black] (17.807,-23.614) arc (47.41806:-240.58194:2.25);
\draw (15.6,-28.16) node [below] {$0,1$};
\fill [black] (15.18,-23.31) -- (14.27,-23.56) -- (15.01,-24.24);
\end{tikzpicture}
\end{center}
\begin{center}
\begin{tabular}{ |c|c|c| } 
 \hline
 \_ & 0 & 1  \\ 
 $\varnothing$ & $\varnothing$ & $\varnothing$\\ 
$ \to{q_{0}}$ & \{$q_{0}, q_{1}$\} &  \{$q_{0}$\}  \\ 
 $\{q_{1}\}$ & $\varnothing$  &  \{$q_{2}$\}     \\ 
 $\{q_{2}\}$ & $\varnothing $ &   $\varnothing  $  \\ 
 $\{q_{0}, q_{1}\}$ & $\{q_{0}, q_{1}\} $ &   $\{q_{0}, q_{2}\}$    \\ 
 $\star\{q_{0}, q_{2}\} $& $\{q_{0}, q_{1}\}$ & $ \{q_{0}\}$ \\ 
 $\star\{q_{1}, q_{2}\} $& $\varnothing \cup \varnothing $& $ \{q_{2}\} $ \\
 $\star\{q_{0}, q_{1}, q_{2}\} $& $\{q_{0}, q_{1}\}$ &  $ \{q_{0}, q_{2}\}$    \\  
 \hline
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{ |c|c|c| } 
 \hline
 A & A & A \\ 
 B & E & B \\ 
 C & A & D \\ 
 D & A & A \\ 
 E & E & F \\ 
 F & E & B \\ 
 G & A & D \\ 
 H & E & F \\
 \hline
\end{tabular}
\end{center}
Contiamo che $S_{D}(\{q_{0},q_{1}\}, 0) = \delta_{N}(q_{0},0) \cup \delta_{N}(q_{1},0)
= \{q_{0},q_{1} \cup \varnothing = \{q_{0}, q_{1}\}\}$ 
Ecco il DFA che ne risulterebbe:
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (19.9,-22.5) circle (3);
\draw (19.9,-22.5) node {$A$};
\draw [black] (16.7,-32.9) circle (3);
\draw (16.7,-32.9) node {$B$};
\draw [black] (35.5,-33.2) circle (3);
\draw (35.5,-33.2) node {$E$};
\draw [black] (33,-8.7) circle (3);
\draw (33,-8.7) node {$C$};
\draw [black] (55.2,-8.1) circle (3);
\draw (55.2,-8.1) node {$D$};
\draw [black] (55.2,-8.1) circle (2.4);
\draw [black] (58.3,-33.5) circle (3);
\draw (58.3,-33.5) node {$F$};
\draw [black] (58.3,-33.5) circle (2.4);
\draw [black] (51.5,-20.5) circle (3);
\draw (51.5,-20.5) node {$G$};
\draw [black] (46.7,-48.6) circle (3);
\draw (46.7,-48.6) node {$H$};
\draw [black] (46.7,-48.6) circle (2.4);
\draw [black] (20.703,-19.621) arc (192.15438:-95.84562:2.25);
\draw (26.17,-16.98) node [above] {$0,1$};
\fill [black] (22.67,-21.39) -- (23.56,-21.71) -- (23.35,-20.73);
\draw [black] (6.1,-32.9) -- (13.7,-32.9);
\draw (5.6,-32.9) node [left] {$Start$};
\fill [black] (13.7,-32.9) -- (12.9,-32.4) -- (12.9,-33.4);
\draw [black] (17.522,-35.773) arc (43.69515:-244.30485:2.25);
\draw (15,-40.13) node [below] {$1$};
\fill [black] (14.92,-35.3) -- (14,-35.49) -- (14.69,-36.21);
\draw [black] (19.7,-32.95) -- (32.5,-33.15);
\fill [black] (32.5,-33.15) -- (31.71,-32.64) -- (31.69,-33.64);
\draw [black] (19.589,-19.525) arc (-181.60736:-265.41138:11.335);
\fill [black] (19.59,-19.52) -- (20.11,-18.74) -- (19.11,-18.71);
\draw (22.17,-10.57) node [left] {$0$};
\draw [black] (52.998,-10.137) arc (-48.93661:-86.67915:50.253);
\fill [black] (22.9,-22.42) -- (23.73,-22.87) -- (23.67,-21.87);
\draw (40.65,-19.31) node [below] {$0,1$};
\draw [black] (36,-8.62) -- (52.2,-8.18);
\fill [black] (52.2,-8.18) -- (51.39,-7.7) -- (51.41,-8.7);
\draw (44.12,-8.93) node [below] {$1$};
\draw [black] (36.823,-35.88) arc (54:-234:2.25);
\draw (35.5,-40.45) node [below] {$0$};
\fill [black] (34.18,-35.88) -- (33.3,-36.23) -- (34.11,-36.82);
\draw [black] (38.009,-31.561) arc (118.45654:60.03576:18.266);
\fill [black] (55.84,-31.8) -- (55.39,-30.96) -- (54.89,-31.83);
\draw (46.96,-28.84) node [above] {$1$};
\draw [black] (55.436,-34.388) arc (-75.4292:-106.0785:32.346);
\fill [black] (38.34,-34.16) -- (38.97,-34.87) -- (39.25,-33.9);
\draw (46.87,-35.94) node [below] {$0$};
\draw [black] (61.13,-34.46) arc (99:-189:2.25);
\draw (63.6,-39.75) node [right] {$1$};
\fill [black] (59.26,-36.33) -- (58.89,-37.2) -- (59.88,-37.04);
\draw [black] (52.36,-17.63) -- (54.34,-10.97);
\fill [black] (54.34,-10.97) -- (53.63,-11.6) -- (54.59,-11.88);
\draw (54.12,-14.9) node [right] {$1$};
\draw [black] (48.81,-21.827) arc (-66.02561:-106.73142:37.56);
\fill [black] (22.74,-23.48) -- (23.36,-24.19) -- (23.65,-23.23);
\draw (36,-25.55) node [below] {$0$};
\draw [black] (44.94,-46.17) -- (37.26,-35.63);
\fill [black] (37.26,-35.63) -- (37.33,-36.57) -- (38.14,-35.98);
\draw (41.69,-39.52) node [right] {$0$};
\draw [black] (48.53,-46.22) -- (56.47,-35.88);
\fill [black] (56.47,-35.88) -- (55.59,-36.21) -- (56.38,-36.82);
\draw (53.07,-42.46) node [right] {$1$};
\end{tikzpicture}
\end{center}
\paragraph{Come si nota è davvero complesso: }
In realtà avremmo dovuto calcolare solo B E ed F, perchè alcuni stati non sono
nemmeno raggiungibili, quindi non avremmo dovuto iniziare indicando tutti i
possibili sottoinsiemi MA considerare il tutto stato per stato:
\begin{center}
\begin{tabular}{ |c|c|c| } 
 \hline
 \_ & 0 & 1 \\
 \hline
 $\to\{q_{0}\} $&$ \{q_{0},q_{1}\}$ & $\{q_{0}\} $\\ 
 $\{q_{0},q_{1}\} $&$\{q_{0},q_{1}\}$ & $\{q_{0},q_{2}\}$ \\ 
 $\star\{q_{0},q_{2}\}$ &$ \{q_{0},q_{1}\}$ & $\{q_{0}\} $\\
 \hline
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{ |c|c|c| } 
 \hline
 B & E & B \\
 E & E & F \\ 
 F & E & B \\ 
 \hline
\end{tabular}
\end{center}
\paragraph{Altro esempio: }Dato il seguente NFA:
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (19.9,-22.5) circle (3);
\draw (19.9,-22.5) node {$A$};
\draw [black] (16.7,-32.9) circle (3);
\draw (16.7,-32.9) node {$B$};
\draw [black] (35.5,-33.2) circle (3);
\draw (35.5,-33.2) node {$E$};
\draw [black] (33,-8.7) circle (3);
\draw (33,-8.7) node {$C$};
\draw [black] (55.2,-8.1) circle (3);
\draw (55.2,-8.1) node {$D$};
\draw [black] (55.2,-8.1) circle (2.4);
\draw [black] (58.3,-33.5) circle (3);
\draw (58.3,-33.5) node {$F$};
\draw [black] (58.3,-33.5) circle (2.4);
\draw [black] (51.5,-20.5) circle (3);
\draw (51.5,-20.5) node {$G$};
\draw [black] (46.7,-48.6) circle (3);
\draw (46.7,-48.6) node {$H$};
\draw [black] (46.7,-48.6) circle (2.4);
\draw [black] (20.703,-19.621) arc (192.15438:-95.84562:2.25);
\draw (26.17,-16.98) node [above] {$0,1$};
\fill [black] (22.67,-21.39) -- (23.56,-21.71) -- (23.35,-20.73);
\draw [black] (6.1,-32.9) -- (13.7,-32.9);
\draw (5.6,-32.9) node [left] {$Start$};
\fill [black] (13.7,-32.9) -- (12.9,-32.4) -- (12.9,-33.4);
\draw [black] (17.522,-35.773) arc (43.69515:-244.30485:2.25);
\draw (15,-40.13) node [below] {$1$};
\fill [black] (14.92,-35.3) -- (14,-35.49) -- (14.69,-36.21);
\draw [black] (19.7,-32.95) -- (32.5,-33.15);
\fill [black] (32.5,-33.15) -- (31.71,-32.64) -- (31.69,-33.64);
\draw [black] (19.589,-19.525) arc (-181.60736:-265.41138:11.335);
\fill [black] (19.59,-19.52) -- (20.11,-18.74) -- (19.11,-18.71);
\draw (22.17,-10.57) node [left] {$0$};
\draw [black] (52.998,-10.137) arc (-48.93661:-86.67915:50.253);
\fill [black] (22.9,-22.42) -- (23.73,-22.87) -- (23.67,-21.87);
\draw (40.65,-19.31) node [below] {$0,1$};
\draw [black] (36,-8.62) -- (52.2,-8.18);
\fill [black] (52.2,-8.18) -- (51.39,-7.7) -- (51.41,-8.7);
\draw (44.12,-8.93) node [below] {$1$};
\draw [black] (36.823,-35.88) arc (54:-234:2.25);
\draw (35.5,-40.45) node [below] {$0$};
\fill [black] (34.18,-35.88) -- (33.3,-36.23) -- (34.11,-36.82);
\draw [black] (38.009,-31.561) arc (118.45654:60.03576:18.266);
\fill [black] (55.84,-31.8) -- (55.39,-30.96) -- (54.89,-31.83);
\draw (46.96,-28.84) node [above] {$1$};
\draw [black] (55.436,-34.388) arc (-75.4292:-106.0785:32.346);
\fill [black] (38.34,-34.16) -- (38.97,-34.87) -- (39.25,-33.9);
\draw (46.87,-35.94) node [below] {$0$};
\draw [black] (61.13,-34.46) arc (99:-189:2.25);
\draw (63.6,-39.75) node [right] {$1$};
\fill [black] (59.26,-36.33) -- (58.89,-37.2) -- (59.88,-37.04);
\draw [black] (52.36,-17.63) -- (54.34,-10.97);
\fill [black] (54.34,-10.97) -- (53.63,-11.6) -- (54.59,-11.88);
\draw (54.12,-14.9) node [right] {$1$};
\draw [black] (48.81,-21.827) arc (-66.02561:-106.73142:37.56);
\fill [black] (22.74,-23.48) -- (23.36,-24.19) -- (23.65,-23.23);
\draw (36,-25.55) node [below] {$0$};
\draw [black] (44.94,-46.17) -- (37.26,-35.63);
\fill [black] (37.26,-35.63) -- (37.33,-36.57) -- (38.14,-35.98);
\draw (41.69,-39.52) node [right] {$0$};
\draw [black] (48.53,-46.22) -- (56.47,-35.88);
\fill [black] (56.47,-35.88) -- (55.59,-36.21) -- (56.38,-36.82);
\draw (53.07,-42.46) node [right] {$1$};
\end{tikzpicture}
\end{center}

\begin{center}
\begin{tabular}{ |c|c|c| } 
 \hline
 $\star \to \{q_{0}\}$& $\{q_{0},q_{2}\}$ & $ \varnothing$\\ 
 $\star\{q_{1},q_{2}\} $& $\{q_{1},q_{2}\} $&$ \{q_{1},q_{3}\}$ \\ 
 $ \varnothing $& $\varnothing$ & $\varnothing$ \\ 
 $\star\{q_{1},q_{3}\} $& $\{q_{1},q_{2}\} $& $\varnothing$\\ 
 \hline
\end{tabular}
\end{center}
Ecco il risultato della conversione in DFA: 
\begin{center}
\includegraphics[width=0.75\textwidth]{24}
\end{center}







\end{document}